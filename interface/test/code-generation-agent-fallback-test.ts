import { describe, it, expect, beforeEach, afterEach } from 'vitest';

// Mock CodeGenerationAgent
class MockCodeGenerationAgent {
  private strategies = [
    'codestral-precise',
    'mistral-large-creative',
    'mistral-large-latest'
  ];
  private fallbackStrategies = [
    'template-based',
    'pattern-based',
    'minimal-functional'
  ];
  private requestCount = 0;
  private shouldFailAllStrategies = false;

  constructor() {
    this.strategies = [
      'codestral-precise',
      'mistral-large-creative',
      'mistral-large-latest'
    ];
    this.fallbackStrategies = [
      'template-based',
      'pattern-based',
      'minimal-functional'
    ];
  }

  setShouldFailAllStrategies(value: boolean) {
    this.shouldFailAllStrategies = value;
  }

  async generateComponentCode(prompt: string, componentName: string): Promise<any> {
    this.requestCount++;
    
    // Try primary strategies first
    for (const strategy of this.strategies) {
      try {
        if (this.shouldFailAllStrategies) {
          throw new Error(`Strategy ${strategy} failed: Rate limit exceeded`);
        }
        
        const result = await this.executeStrategy(strategy, prompt, componentName);
        if (result && result.success) {
          return {
            success: true,
            code: result.code,
            strategy: strategy,
            confidence: result.confidence
          };
        }
      } catch (error) {
        console.log(`[CodeGenerationAgent] Strategy ${strategy} failed:`, error.message);
        continue;
      }
    }

    // If all primary strategies fail, try fallback strategies
    console.log('[CodeGenerationAgent] All primary strategies failed, trying fallbacks...');
    
    for (const fallbackStrategy of this.fallbackStrategies) {
      try {
        const result = await this.executeFallbackStrategy(fallbackStrategy, prompt, componentName);
        if (result && result.success) {
          return {
            success: true,
            code: result.code,
            strategy: fallbackStrategy,
            confidence: result.confidence,
            isFallback: true
          };
        }
      } catch (error) {
        console.log(`[CodeGenerationAgent] Fallback strategy ${fallbackStrategy} failed:`, error.message);
        continue;
      }
    }

    // If all strategies fail, return minimal functional code
    return {
      success: true,
      code: this.generateMinimalCode(componentName),
      strategy: 'minimal-functional',
      confidence: 0.3,
      isFallback: true,
      isMinimal: true
    };
  }

  private async executeStrategy(strategy: string, prompt: string, componentName: string): Promise<any> {
    // Simulate API call with potential failure
    await new Promise(resolve => setTimeout(resolve, 50));
    
    if (this.shouldFailAllStrategies) {
      throw new Error(`API error occurred: Status 429 Rate limit exceeded`);
    }
    
    return {
      success: true,
      code: `<!-- ${componentName}.astro -->\n<div class="${componentName.toLowerCase()}">\n  <h1>${componentName}</h1>\n  <p>Generated by ${strategy}</p>\n</div>`,
      confidence: 0.8
    };
  }

  private async executeFallbackStrategy(strategy: string, prompt: string, componentName: string): Promise<any> {
    await new Promise(resolve => setTimeout(resolve, 30));
    
    switch (strategy) {
      case 'template-based':
        return {
          success: true,
          code: this.generateTemplateCode(componentName),
          confidence: 0.6
        };
      case 'pattern-based':
        return {
          success: true,
          code: this.generatePatternCode(componentName),
          confidence: 0.5
        };
      case 'minimal-functional':
        return {
          success: true,
          code: this.generateMinimalCode(componentName),
          confidence: 0.4
        };
      default:
        throw new Error(`Unknown fallback strategy: ${strategy}`);
    }
  }

  private generateTemplateCode(componentName: string): string {
    return `---
interface ${componentName}Props {
  title?: string;
  content?: string;
}

const { title = "${componentName}", content = "Default content" } = Astro.props;
---

<section class="${componentName.toLowerCase()}-section">
  <div class="container mx-auto px-4">
    <h2 class="text-2xl font-bold mb-4">{title}</h2>
    <p class="text-gray-600">{content}</p>
  </div>
</section>`;
  }

  private generatePatternCode(componentName: string): string {
    return `---
// ${componentName} component generated from pattern
---

<div class="${componentName.toLowerCase()}-component bg-white p-6 rounded-lg shadow-md">
  <h3 class="text-xl font-semibold mb-3">${componentName}</h3>
  <div class="space-y-2">
    <p class="text-gray-700">Pattern-based component</p>
  </div>
</div>`;
  }

  private generateMinimalCode(componentName: string): string {
    return `---
// Minimal ${componentName} component
---

<div class="${componentName.toLowerCase()}">
  <h1>${componentName}</h1>
  <p>Minimal functional component</p>
</div>`;
  }

  async selectBestResult(results: any[]): Promise<any> {
    if (results.length === 0) {
      throw new Error('No successful generation results');
    }

    // Sort by confidence and prefer non-fallback results
    const sortedResults = results.sort((a, b) => {
      if (a.isFallback && !b.isFallback) return 1;
      if (!a.isFallback && b.isFallback) return -1;
      return (b.confidence || 0) - (a.confidence || 0);
    });

    return sortedResults[0];
  }
}

describe('CodeGenerationAgent Fallback Strategies', () => {
  let agent: MockCodeGenerationAgent;

  beforeEach(() => {
    agent = new MockCodeGenerationAgent();
  });

  it('should try all primary strategies before fallbacks', async () => {
    agent.setShouldFailAllStrategies(true);
    
    const result = await agent.generateComponentCode(
      'Create a modern hero section',
      'Hero'
    );
    
    expect(result.success).toBe(true);
    expect(result.isFallback).toBe(true);
    expect(result.strategy).toBe('minimal-functional');
    expect(result.confidence).toBe(0.3);
  });

  it('should use primary strategy when available', async () => {
    agent.setShouldFailAllStrategies(false);
    
    const result = await agent.generateComponentCode(
      'Create a modern hero section',
      'Hero'
    );
    
    expect(result.success).toBe(true);
    expect(result.isFallback).toBeUndefined();
    expect(result.strategy).toBe('codestral-precise');
    expect(result.confidence).toBe(0.8);
  });

  it('should generate template-based fallback code', async () => {
    agent.setShouldFailAllStrategies(true);
    
    // Mock to make template-based strategy succeed
    const originalExecuteFallbackStrategy = agent['executeFallbackStrategy'];
    agent['executeFallbackStrategy'] = async (strategy: string, prompt: string, componentName: string) => {
      if (strategy === 'template-based') {
        return {
          success: true,
          code: agent['generateTemplateCode'](componentName),
          confidence: 0.6
        };
      }
      throw new Error('Strategy failed');
    };
    
    const result = await agent.generateComponentCode(
      'Create a modern hero section',
      'Hero'
    );
    
    expect(result.success).toBe(true);
    expect(result.strategy).toBe('template-based');
    expect(result.code).toContain('interface HeroProps');
    expect(result.code).toContain('Hero');
  });

  it('should generate pattern-based fallback code', async () => {
    agent.setShouldFailAllStrategies(true);
    
    // Mock to make pattern-based strategy succeed
    const originalExecuteFallbackStrategy = agent['executeFallbackStrategy'];
    agent['executeFallbackStrategy'] = async (strategy: string, prompt: string, componentName: string) => {
      if (strategy === 'pattern-based') {
        return {
          success: true,
          code: agent['generatePatternCode'](componentName),
          confidence: 0.5
        };
      }
      throw new Error('Strategy failed');
    };
    
    const result = await agent.generateComponentCode(
      'Create a modern hero section',
      'Hero'
    );
    
    expect(result.success).toBe(true);
    expect(result.strategy).toBe('pattern-based');
    expect(result.code).toContain('Pattern-based component');
  });

  it('should generate minimal code when all strategies fail', async () => {
    agent.setShouldFailAllStrategies(true);
    
    const result = await agent.generateComponentCode(
      'Create a modern hero section',
      'Hero'
    );
    
    expect(result.success).toBe(true);
    expect(result.strategy).toBe('minimal-functional');
    expect(result.isMinimal).toBe(true);
    expect(result.code).toContain('Minimal functional component');
  });

  it('should select best result from multiple successful generations', async () => {
    const results = [
      { success: true, confidence: 0.8, strategy: 'primary' },
      { success: true, confidence: 0.6, strategy: 'fallback', isFallback: true },
      { success: true, confidence: 0.4, strategy: 'minimal', isFallback: true, isMinimal: true }
    ];
    
    const bestResult = await agent.selectBestResult(results);
    
    expect(bestResult.strategy).toBe('primary');
    expect(bestResult.confidence).toBe(0.8);
    expect(bestResult.isFallback).toBeUndefined();
  });

  it('should handle case when no results are provided', async () => {
    await expect(agent.selectBestResult([])).rejects.toThrow('No successful generation results');
  });

  it('should continue working after rate limit errors', async () => {
    agent.setShouldFailAllStrategies(true);
    
    // First attempt should fail but return minimal code
    const result1 = await agent.generateComponentCode('Test prompt', 'TestComponent');
    expect(result1.success).toBe(true);
    expect(result1.isMinimal).toBe(true);
    
    // Second attempt should also work
    const result2 = await agent.generateComponentCode('Another test', 'AnotherComponent');
    expect(result2.success).toBe(true);
    expect(result2.isMinimal).toBe(true);
  });
}); 