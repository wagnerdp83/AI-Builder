import { promises as fs } from 'fs';
import path from 'path';
import { getComponentsDir, getPagesDir, getRenderingDir } from '../utils/directory';
import { Mistral } from '@mistralai/mistralai';
import { exec } from 'child_process';
import { getMockupImagePath } from './imageUtils';
import { executeVisionCreator } from './visionCreateHandler';
import { PromptEnhancer } from '../services/prompt-enhancer';
// import { enhancedImageService } from '../services/image-service'; // COMMENTED OUT - Image service should only run during Astro component building, not in Next.js runtime
import { DomainSecurityService } from '../services/domain-security';
import { IRLService } from '../services/irl-service';
import { FeedbackLearningService } from '../services/feedback-learning';
import { ConversationalRecoveryService } from '../services/conversational-recovery';
import { SmartImageExtractor } from '../services/smart-image-extractor';
import { UserIntent } from '../types/intent-types';
import { IntentDetectionService } from '../services/intent-detection';
import { ComponentKnowledgeBase } from '../services/component-knowledge-base';

const mistralApiKey = process.env.MISTRAL_API_KEY;
if (!mistralApiKey) {
  throw new Error('MISTRAL_API_KEY is not configured in the environment.');
}
const mistralClient = new Mistral({ apiKey: mistralApiKey });

// =================================================================================
// START: Standalone Astro Validator Service
// =================================================================================
const MAX_RETRIES = 2;

class AstroValidator {
  static async validateAndFix(code: string): Promise<string> {
    const renderingDir = getRenderingDir();
    let currentCode = code;
    for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
      const { isValid, error } = await this.compileAstro(currentCode, renderingDir);
      if (isValid) {
        console.log('‚úÖ Astro code validation successful.');
        return currentCode;
      }
      console.warn(`Ô∏è Astro validation failed on attempt ${attempt + 1}. Error: ${error}`);
      if (attempt < MAX_RETRIES) {
        console.log(`Retrying with AI-powered correction...`);
        currentCode = await this.getAiFix(currentCode, error);
      } else {
        console.error(`‚ùå AI failed to fix the Astro code after ${MAX_RETRIES} attempts.`);
        throw new Error(`Failed to generate valid Astro code. Last error: ${error}`);
      }
    }
    throw new Error('Exited validation loop unexpectedly.');
  }

  private static async compileAstro(code: string, renderingDir: string): Promise<{ isValid: boolean, error: string | null }> {
    const tmpDir = path.join(renderingDir, 'src', 'components', '.tmp');
    await fs.mkdir(tmpDir, { recursive: true });
    const tmpFile = path.join(tmpDir, `validation-test-${Date.now()}.astro`);
    try {
      await fs.writeFile(tmpFile, code);
      const command = `npx --no-install astro check --fail-on-warnings "${tmpFile}"`;
      return await new Promise((resolve) => {
        exec(command, { cwd: renderingDir }, (err, stdout, stderr) => {
          // Only show errors related to tmpFile (suppress global Astro/TS errors)
          const allOutput = (stderr || stdout) || '';
          const filtered = allOutput
            .split('\n')
            .filter(line => line.includes(path.basename(tmpFile)))
            .join('\n');
          if (err || filtered) {
            if (!filtered && (stderr || stdout)) {
              // Fallback: if filtered is empty but there is an error, use the full error output
              console.warn('[AstroValidator] Filtered error is empty, falling back to full error output:');
              console.warn(allOutput);
              resolve({ isValid: false, error: allOutput });
            } else {
              resolve({ isValid: false, error: filtered });
            }
          } else {
            resolve({ isValid: true, error: null });
          }
        });
      });
    } finally {
      await fs.unlink(tmpFile).catch(() => console.error(`Failed to delete temp file: ${tmpFile}`));
    }
  }

  private static async getAiFix(code: string, error: string | null): Promise<string> {
    const systemPrompt = `You are an expert Astro developer and problem-solver. You will be given a piece of Astro code that has a compilation error. Your job is to analyze the error, understand the original developer's intent, and fix the code to be both syntactically correct and functionally complete.

**CRITICAL INSTRUCTIONS:**
1.  **Analyze the Error:** The provided error message will tell you what's wrong (e.g., a component is not exported, a variable is undefined).
2.  **Deduce the Intent:** Look at the broken code. If an icon like \`Google\` is being imported from \`@lucide/astro\` and fails, the developer likely wanted a Google icon. Do not just delete the broken code.
3.  **Find a Solution:** If an import is wrong, find the correct one. For example, the \`lucide\` library often uses brand names directly (e.g., \`Youtube\`, \`Twitter\`). You may need to search for the correct icon name if the provided one is wrong. If an icon truly doesn't exist in \`@lucide/astro\`, you can substitute it with a similar, existing icon (e.g., use a generic \`Mail\` icon if a specific email provider icon is missing).
4.  **Preserve Functionality:** Your primary goal is to make the component work as intended. Deleting features to fix a compilation error is a last resort.
5.  **Respond with Code Only:** Your response MUST be ONLY the corrected, complete Astro code. Do not add any explanations or markdown.`;
    const userMessage = `The following Astro code produced an error. Please fix it.\n\nError Message:\n---\n${error}\n---\n\nBroken Code:\n---\n${code}\n---`;
    const response = await mistralClient.chat.complete({
        model: 'codestral-2405',
        messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userMessage }],
        temperature: 0.1,
    });
    const fixedCode = response.choices[0].message.content;
    if (!fixedCode || typeof fixedCode !== 'string') {
        throw new Error('AI failed to return valid string code for the fix.');
    }
    return fixedCode.replace(/```(astro)?/g, '').trim();
  }
}
// =================================================================================
// END: Standalone Astro Validator Service
// =================================================================================

// === AbstractAstroValidator: Dedicated validator for abstract pipeline ===
// import path from 'path'; // Duplicate, already imported above
// import { promises as fs } from 'fs'; // Duplicate, already imported above
// import { exec } from 'child_process'; // Duplicate, already imported above
// import { Mistral } from '@mistralai/mistralai'; // Duplicate, already imported above
// const mistralApiKey = process.env.MISTRAL_API_KEY; // Duplicate, already declared above
// const mistralClient = new Mistral({ apiKey: mistralApiKey }); // Duplicate, already declared above
// const MAX_RETRIES = 2; // Duplicate, already declared above

export class AbstractAstroValidator {
  static async validateAndFix(code: string, renderingDir: string): Promise<string> {
    let currentCode = code;
    for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
      const { isValid, error } = await this.compileAstro(currentCode, renderingDir);
      if (isValid) {
        console.log('[AbstractAstroValidator] ‚úÖ Astro code validation successful.');
        return currentCode;
      }
      console.warn(`[AbstractAstroValidator] ‚ö†Ô∏è Astro validation failed on attempt ${attempt + 1}. Error: ${error}`);
      if (attempt < MAX_RETRIES) {
        console.log('[AbstractAstroValidator] Retrying with AI-powered correction...');
        currentCode = await this.getAiFix(currentCode, error);
      } else {
        console.error('[AbstractAstroValidator] ‚ùå AI failed to fix the Astro code after max attempts.');
        throw new Error(`Failed to generate valid Astro code. Last error: ${error}`);
      }
    }
    throw new Error('[AbstractAstroValidator] Exited validation loop unexpectedly.');
  }
  private static async compileAstro(code: string, renderingDir: string): Promise<{ isValid: boolean, error: string | null }> {
    const tmpDir = path.join(renderingDir, 'src', 'components', '.tmp');
    await fs.mkdir(tmpDir, { recursive: true });
    const tmpFile = path.join(tmpDir, `abstract-validation-test-${Date.now()}.astro`);
    try {
      await fs.writeFile(tmpFile, code);
      const command = `npx --no-install astro check --fail-on-warnings "${tmpFile}"`;
      return await new Promise((resolve) => {
        exec(command, { cwd: renderingDir }, (err, stdout, stderr) => {
          const allOutput = (stderr || stdout) || '';
          if (err || allOutput) {
            resolve({ isValid: false, error: allOutput });
          } else {
            resolve({ isValid: true, error: null });
          }
        });
      });
    } finally {
      await fs.unlink(tmpFile).catch(() => console.error(`[AbstractAstroValidator] Failed to delete temp file: ${tmpFile}`));
    }
  }
  private static async getAiFix(code: string, error: string | null): Promise<string> {
    const systemPrompt = `You are an expert Astro developer. You will be given a piece of Astro code that has an error, along with the error message from the compiler. Your ONLY job is to fix the code to resolve the error. Respond with ONLY the corrected, complete Astro code. Do not add any explanations, markdown, or apologies.`;
    const userMessage = `The following Astro code produced an error. Please fix it.\n\nError Message:\n---\n${error}\n---\n\nBroken Code:\n---\n${code}\n---`;
    const response = await mistralClient.chat.complete({
      model: 'codestral-2405',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userMessage }
      ],
      temperature: 0.1,
    });
    const fixedCode = response.choices[0].message.content;
    if (!fixedCode) {
      throw new Error('[AbstractAstroValidator] AI failed to return any code for the fix.');
    }
    // Fix for linter: only call .replace on string
    if (typeof fixedCode === 'string') {
      return fixedCode.replace(/```(astro)?/g, '').trim();
    }
    // If not a string, return as is or throw
    // return fixedCode;
    throw new Error('AI failed to return valid string code for the fix.');
  }
}

// === GenericAstroValidator: Dedicated validator for generic pipeline ===
// import path from 'path'; // Duplicate, already imported above
// import { promises as fs } from 'fs'; // Duplicate, already imported above
// import { exec } from 'child_process'; // Duplicate, already imported above
// import { Mistral } from '@mistralai/mistralai'; // Duplicate, already declared above
// const mistralApiKey = process.env.MISTRAL_API_KEY; // Duplicate, already declared above
// const mistralClient = new Mistral({ apiKey: mistralApiKey }); // Duplicate, already declared above
// const MAX_RETRIES = 2; // Duplicate, already declared above

// === GENERIC PIPELINE DEDICATED CONSTANTS ===
const GENERIC_MAX_RETRIES = 2; // Keep this one active

// === DYNAMIC PROMPT GENERATOR ===
import { DynamicPromptGenerator } from '../services/dynamic-prompt-generator';

const dynamicPromptGenerator = new DynamicPromptGenerator();

export class GenericAstroValidator {
  static async validateAndFix(code: string, renderingDir: string): Promise<string> {
    let currentCode = code;
    for (let attempt = 0; attempt <= GENERIC_MAX_RETRIES; attempt++) {
      const { isValid, error } = await this.compileAstro(currentCode, renderingDir);
      if (isValid) {
        console.log('[GenericAstroValidator] ‚úÖ Astro code validation successful.');
        return currentCode;
      }
      console.warn(`[GenericAstroValidator] ‚ö†Ô∏è Astro validation failed on attempt ${attempt + 1}. Error: ${error}`);
      if (attempt < GENERIC_MAX_RETRIES) {
        console.log('[GenericAstroValidator] Retrying with AI-powered correction...');
        currentCode = await this.getAiFix(currentCode, error);
      } else {
        console.error('[GenericAstroValidator] ‚ùå AI failed to fix the Astro code after max attempts.');
        throw new Error(`Failed to generate valid Astro code. Last error: ${error}`);
      }
    }
    throw new Error('[GenericAstroValidator] Exited validation loop unexpectedly.');
  }
  private static async compileAstro(code: string, renderingDir: string): Promise<{ isValid: boolean, error: string | null }> {
    const tmpDir = path.join(renderingDir, 'src', 'components', '.tmp');
    await fs.mkdir(tmpDir, { recursive: true });
    const tmpFile = path.join(tmpDir, `generic-validation-test-${Date.now()}.astro`);
    try {
      await fs.writeFile(tmpFile, code);
      const command = `npx --no-install astro check --fail-on-warnings "${tmpFile}"`;
      return await new Promise((resolve) => {
        exec(command, { cwd: renderingDir }, (err, stdout, stderr) => {
          const allOutput = (stderr || stdout) || '';
          if (err || allOutput) {
            resolve({ isValid: false, error: allOutput });
          } else {
            resolve({ isValid: true, error: null });
          }
        });
      });
    } finally {
      await fs.unlink(tmpFile).catch(() => console.error(`[GenericAstroValidator] Failed to delete temp file: ${tmpFile}`));
    }
  }
  private static async getAiFix(code: string, error: string | null): Promise<string> {
    const systemPrompt = `You are an expert Astro developer. You will be given a piece of Astro code that has an error, along with the error message from the compiler. Your ONLY job is to fix the code to resolve the error. Respond with ONLY the corrected, complete Astro code. Do not add any explanations, markdown, or apologies.`;
    const userMessage = `The following Astro code produced an error. Please fix it.\n\nError Message:\n---\n${error}\n---\n\nBroken Code:\n---\n${code}\n---`;
    const response = await mistralClient.chat.complete({
      model: 'codestral-2405',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userMessage }
      ],
      temperature: 0.1,
    });
    const fixedCode = response.choices[0].message.content;
    if (!fixedCode) {
      throw new Error('[GenericAstroValidator] AI failed to return any code for the fix.');
    }
    // Fix for linter: only call .replace on string
    if (typeof fixedCode === 'string') {
      return fixedCode.replace(/```(astro)?/g, '').trim();
    }
    // If not a string, return as is or throw
    // return fixedCode;
    throw new Error('AI failed to return valid string code for the fix.');
  }
}

// === SingleAstroValidator: Dedicated validator for single pipeline ===
// import path from 'path'; // Duplicate, already imported above
// import { promises as fs } from 'fs'; // Duplicate, already imported above
// import { exec } from 'child_process'; // Duplicate, already imported above
// import { Mistral } from '@mistralai/mistralai'; // Duplicate, already imported above
// const mistralApiKey = process.env.MISTRAL_API_KEY; // Duplicate, already declared above
// const mistralClient = new Mistral({ apiKey: mistralApiKey }); // Duplicate, already declared above
// const MAX_RETRIES = 2; // Duplicate, already declared above

export class SingleAstroValidator {
  static async validateAndFix(code: string, renderingDir: string): Promise<string> {
    let currentCode = code;
    for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
      const { isValid, error } = await this.compileAstro(currentCode, renderingDir);
      if (isValid) {
        console.log('[SingleAstroValidator] ‚úÖ Astro code validation successful.');
        return currentCode;
      }
      console.warn(`[SingleAstroValidator] ‚ö†Ô∏è Astro validation failed on attempt ${attempt + 1}. Error: ${error}`);
      if (attempt < MAX_RETRIES) {
        console.log('[SingleAstroValidator] Retrying with AI-powered correction...');
        currentCode = await this.getAiFix(currentCode, error);
      } else {
        console.error('[SingleAstroValidator] ‚ùå AI failed to fix the Astro code after max attempts.');
        throw new Error(`Failed to generate valid Astro code. Last error: ${error}`);
      }
    }
    throw new Error('[SingleAstroValidator] Exited validation loop unexpectedly.');
  }
  private static async compileAstro(code: string, renderingDir: string): Promise<{ isValid: boolean, error: string | null }> {
    const tmpDir = path.join(renderingDir, 'src', 'components', '.tmp');
    await fs.mkdir(tmpDir, { recursive: true });
    const tmpFile = path.join(tmpDir, `single-validation-test-${Date.now()}.astro`);
    try {
      await fs.writeFile(tmpFile, code);
      const command = `npx --no-install astro check --fail-on-warnings "${tmpFile}"`;
      return await new Promise((resolve) => {
        exec(command, { cwd: renderingDir }, (err, stdout, stderr) => {
          const allOutput = (stderr || stdout) || '';
          if (err || allOutput) {
            resolve({ isValid: false, error: allOutput });
          } else {
            resolve({ isValid: true, error: null });
          }
        });
      });
    } finally {
      await fs.unlink(tmpFile).catch(() => console.error(`[SingleAstroValidator] Failed to delete temp file: ${tmpFile}`));
    }
  }
  private static async getAiFix(code: string, error: string | null): Promise<string> {
    const systemPrompt = `You are an expert Astro developer. You will be given a piece of Astro code that has an error, along with the error message from the compiler. Your ONLY job is to fix the code to resolve the error. Respond with ONLY the corrected, complete Astro code. Do not add any explanations, markdown, or apologies.`;
    const userMessage = `The following Astro code produced an error. Please fix it.\n\nError Message:\n---\n${error}\n---\n\nBroken Code:\n---\n${code}\n---`;
    const response = await mistralClient.chat.complete({
      model: 'codestral-2405',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userMessage }
      ],
      temperature: 0.1,
    });
    const fixedCode = response.choices[0].message.content;
    if (!fixedCode) {
      throw new Error('[SingleAstroValidator] AI failed to return any code for the fix.');
    }
    // Fix for linter: only call .replace on string
    if (typeof fixedCode === 'string') {
      return fixedCode.replace(/```(astro)?/g, '').trim();
    }
    // If not a string, return as is or throw
    // return fixedCode;
    throw new Error('AI failed to return valid string code for the fix.');
  }
}

const CODEGEN_SYSTEM_PROMPT = `You are a world-class AI developer specializing in creating production-ready Astro components using Tailwind CSS and Preline UI. Your code should be clean, semantic, and follow best practices.

**CRITICAL DIRECTIVES:**
1.  **ATOMIC COMPONENTS (STRICT):**
    *   **ONE SECTION ONLY:** Each component MUST contain ONLY its designated section. If creating a "Menu" component, it should contain ONLY the navigation/menu section. If creating a "Hero" component, it should contain ONLY the hero section. NEVER include multiple sections in a single component.
    *   **NO FULL PAGES:** Do NOT create complete landing pages with multiple sections. Each component is a building block that will be assembled into a complete page later.
    *   **NO HTML/HEAD/BODY:** Do NOT include <!DOCTYPE html>, <html>, <head>, or <body> tags. These are page-level elements, not component-level elements.

2.  **TECH STACK:**
    *   **Astro:** Generate a valid, single-file Astro component (.astro).
    *   **Tailwind CSS:** All styling MUST be done with Tailwind CSS utility classes.
    *   **Preline UI:** You MUST use Preline UI components (see https://preline.co/ for components like headers, dropdowns, cards, etc.) to create modern, professional-looking layouts. This is a strict requirement for design consistency.

3.  **CODE QUALITY:**
    *   **Correct Tag Usage:** You MUST use the correct, top-level semantic HTML tag. For example, a component named \`Footer\` MUST use a \`<footer>\` tag, not \`<header>\`. A component named \`Testimonial\` or \`Hero\` should use a \`<section>\` tag.
    *   **Semantic HTML:** Use appropriate HTML5 tags like \`<header>\`, \`<nav>\`, \`<section>\`, \`<figure>\`, etc. For a navigation bar, use \`<header>\` and \`<nav>\`.
    *   **Data Separation (Strict):** You MUST separate content from presentation. ALL text content (headings, paragraphs, button text, labels, etc.), link URLs, and lists of items MUST be defined as constants in the \`---\` frontmatter. The HTML body must then reference these variables. **There are no exceptions to this rule; do not hardcode ANY text directly in the HTML body.**
    *   **Dynamic & Reusable:** Avoid hardcoding content. For navigation links, generate anchor links (e.g., \`href="#faq"\`) based on the item name. For logos or brand names, use a generic placeholder like "Logo" or "Brand Name" that is easy for the user to replace.
    *   **Production-Ready:** The generated component must be complete and ready to use. No "Lorem Ipsum" or unfinished parts.

3.  **NAVIGATION COMPONENTS:**
    *   **Structure:** Navigation items MUST be defined as an array in the frontmatter with all properties (text, href, submenu items).
    *   **Layout:** Follow the user's layout instructions exactly (e.g., "logo on left, items on right").
    *   **Submenus:** If a menu item has submenus, use Preline's dropdown component (\`hs-dropdown\`) and nest the submenu items properly.
    *   **Mobile:** Always include a mobile-responsive hamburger menu using Preline's collapse component.

4.  **COMPONENT STRUCTURE:**
    *   Only include a \`---\` frontmatter section if you need to define props or import something. Keep it minimal. Most components should not need it.

5.  **RESPONSE FORMAT:**
    *   Your response MUST be ONLY the raw Astro code. No explanations, no markdown, no apologies. Just the code.

**EXAMPLE OF A GOOD ATOMIC MENU COMPONENT:**
\`\`\`astro
---
const navItems = [
  { text: "Home", href: "#home" },
  { text: "Features", href: "#features", submenu: [
    { text: "Core Features", href: "#core-features" },
    { text: "Advanced", href: "#advanced" }
  ]},
  { text: "Pricing", href: "#pricing" }
];

const brandName = "Your Brand";
---
<header class="flex flex-wrap sm:justify-start sm:flex-nowrap z-50 w-full bg-white text-sm py-3 sm:py-0">
  <nav class="relative max-w-7xl w-full mx-auto px-4 sm:flex sm:items-center sm:justify-between sm:px-6 lg:px-8" aria-label="Global">
    <div class="flex items-center justify-between">
      <a class="flex-none text-xl font-semibold" href="#" aria-label="Brand">{brandName}</a>
      <div class="sm:hidden">
        <button type="button" class="hs-collapse-toggle p-2 inline-flex justify-center items-center gap-2 rounded-lg border font-medium bg-white text-gray-700 shadow-sm align-middle hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-white focus:ring-blue-600 transition-all text-sm" data-hs-collapse="#navbar-collapse-with-animation" aria-controls="navbar-collapse-with-animation" aria-label="Toggle navigation">
          <svg class="hs-collapse-open:hidden flex-shrink-0 size-4" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" x2="21" y1="6" y2="6"/><line x1="3" x2="21" y1="12" y2="12"/><line x1="3" x2="21" y1="18" y2="18"/></svg>
          <svg class="hs-collapse-open:block hidden flex-shrink-0 size-4" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
        </button>
      </div>
    </div>
    <div id="navbar-collapse-with-animation" class="hs-collapse hidden overflow-hidden transition-all duration-300 basis-full grow sm:block">
      <div class="flex flex-col gap-y-4 gap-x-0 mt-5 sm:flex-row sm:items-center sm:justify-end sm:gap-y-0 sm:gap-x-7 sm:mt-0 sm:ps-7">
        {navItems.map(item => (
          <div class="hs-dropdown relative inline-flex">
            <a class="font-medium text-gray-500 hover:text-gray-400 sm:py-6" href={item.href}>{item.text}</a>
            {item.submenu && (
              <div class="hs-dropdown-menu transition-[opacity,margin] duration hs-dropdown-open:opacity-100 opacity-0 hidden min-w-60 bg-white shadow-md rounded-lg p-2 mt-2" aria-labelledby="hs-dropdown-basic">
                {item.submenu.map(subItem => (
                  <a class="flex items-center gap-x-3.5 py-2 px-3 rounded-lg text-sm text-gray-800 hover:bg-gray-100 focus:ring-2 focus:ring-blue-500" href={subItem.href}>{subItem.text}</a>
                ))}
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  </nav>
</header>
\`\`\`

**EXAMPLE OF A GOOD ATOMIC HERO COMPONENT:**
\`\`\`astro
---
const heroTitle = "Find Your Dream Home";
const heroSubtitle = "Discover the perfect property with our expert guidance.";
const heroButtonText = "Get Started";
---
<section class="bg-gray-100 py-20">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
    <h1 class="text-4xl font-bold text-gray-900">{heroTitle}</h1>
    <p class="mt-4 text-lg text-gray-600">{heroSubtitle}</p>
    <a href="#features" class="mt-8 inline-block bg-blue-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-blue-700">{heroButtonText}</a>
    <img src={heroImage} alt={heroAltText} class="mt-10 w-full h-auto rounded-lg shadow-lg" />
  </div>
</section>
\`\`\`
`;

export interface GenerateFileInstructions {
  componentName: string;
  generationPrompt: string;
  originalPrompt: string;
  mode?: 'abstract' | 'vision' | 'edit' | string; // for future extensibility
  componentNames?: string[]; // for abstract mode
}

// === SINGLE PIPELINE DEDICATED CONSTANTS ===
const SINGLE_MAX_RETRIES = 2;
const SINGLE_CODEGEN_SYSTEM_PROMPT = `You are a world-class AI developer specializing in creating production-ready Astro components using Tailwind CSS and Preline UI. Your code should be clean, semantic, and follow best practices.

**AVATAR REQUIREMENT:** For testimonials, use ONLY these exact filenames: Avatar_man.avif, Avatar_man2.avif, Avatar_man3.avif, Avatar_man4.avif, Avatar_man6.avif, Avatar_man7.avif, Avatar_woman.avif, Avatar_woman2.avif, Avatar_woman3.avif, Avatar_woman4.avif, Avatar_woman5.avif

**CRITICAL DIRECTIVES:**
1.  **ATOMIC COMPONENTS (STRICT):**
    *   **ONE SECTION ONLY:** Each component MUST contain ONLY its designated section. If creating a "Menu" component, it should contain ONLY the navigation/menu section. If creating a "Hero" component, it should contain ONLY the hero section. NEVER include multiple sections in a single component.
    *   **NO FULL PAGES:** Do NOT create complete landing pages with multiple sections. Each component is a building block that will be assembled into a complete page later.
    *   **NO HTML/HEAD/BODY:** Do NOT include <!DOCTYPE html>, <html>, <head>, or <body> tags. These are page-level elements, not component-level elements.

2.  **TECH STACK:**
    *   **Astro:** Generate a valid, single-file Astro component (.astro).
    *   **Tailwind CSS:** All styling MUST be done with Tailwind CSS utility classes.
    *   **Preline UI:** You MUST use Preline UI components (see https://preline.co/ for components like headers, dropdowns, cards, etc.) to create modern, professional-looking layouts. This is a strict requirement for design consistency.

3.  **IMAGES AND VISUAL CONTENT (CRITICAL):**
    *   **ALWAYS INCLUDE IMAGES:** Every component MUST include relevant images, icons, and visual elements. This is NOT optional.
    *   **Image Sources:** Use high-quality images from:

      - Lucide ASTRO icons for icons (import from \`@lucide/astro\`)
      - Font Awesome icons when needed
    *   **Image Types by Component:**
      - **Hero:** Background images, product images, lifestyle photos
      - **Features:** Icons, product mockups, screenshots
      - **Testimonials:** Avatar images, customer photos
      - **Products:** Product images, mockups, lifestyle shots
      - **Gallery:** Multiple high-quality images
      - **About:** Team photos, office images, process diagrams
    *   **Image Optimization:** Always include \`alt\` attributes and responsive sizing
    *   **Visual Hierarchy:** Use images to create visual interest and guide user attention

4.  **CODE QUALITY:**
    *   **Correct Tag Usage:** You MUST use the correct, top-level semantic HTML tag. For example, a component named \`Footer\` MUST use a \`<footer>\` tag, not \`<header>\`. A component named \`Testimonial\` or \`Hero\` should use a \`<section>\` tag.
    *   **Semantic HTML:** Use appropriate HTML5 tags like \`<header>\`, \`<nav>\`, \`<section>\`, \`<figure>\`, etc. For a navigation bar, use \`<header>\` and \`<nav>\`.
    *   **Data Separation (Strict):** You MUST separate content from presentation. ALL text content (headings, paragraphs, button text, labels, etc.), link URLs, and lists of items MUST be defined as constants in the \`---\` frontmatter. The HTML body must then reference these variables. **There are no exceptions to this rule; do not hardcode ANY text directly in the HTML body.**
    *   **Dynamic & Reusable:** Avoid hardcoding content. For navigation links, generate anchor links (e.g., \`href="#faq"\`) based on the item name. For logos or brand names, use a generic placeholder like "Logo" or "Brand Name" that is easy for the user to replace.
    *   **Production-Ready:** The generated component must be complete and ready to use. No "Lorem Ipsum" or unfinished parts.

5.  **NAVIGATION COMPONENTS:**
    *   **Structure:** Navigation items MUST be defined as an array in the frontmatter with all properties (text, href, submenu items).
    *   **Layout:** Follow the user's layout instructions exactly (e.g., "logo on left, items on right").
    *   **Submenus:** If a menu item has submenus, use Preline's dropdown component (\`hs-dropdown\`) and nest the submenu items properly.
    *   **Mobile:** Always include a mobile-responsive hamburger menu using Preline's collapse component.

6.  **COMPONENT STRUCTURE:**
    *   Only include a \`---\` frontmatter section if you need to define props or import something. Keep it minimal. Most components should not need it.

7.  **RESPONSE FORMAT:**
    *   Your response MUST be ONLY the raw Astro code. No explanations, no markdown, no apologies. Just the code.

**EXAMPLE OF A GOOD ATOMIC MENU COMPONENT:**
\`\`\`astro
---
const navItems = [
  { text: "Home", href: "#home" },
  { text: "Features", href: "#features", submenu: [
    { text: "Core Features", href: "#core-features" },
    { text: "Advanced", href: "#advanced" }
  ]},
  { text: "Pricing", href: "#pricing" }
];

const brandName = "Your Brand";
---
<header class="flex flex-wrap sm:justify-start sm:flex-nowrap z-50 w-full bg-white text-sm py-3 sm:py-0">
  <nav class="relative max-w-7xl w-full mx-auto px-4 sm:flex sm:items-center sm:justify-between sm:px-6 lg:px-8" aria-label="Global">
    <div class="flex items-center justify-between">
      <a class="flex-none text-xl font-semibold" href="#" aria-label="Brand">{brandName}</a>
      <div class="sm:hidden">
        <button type="button" class="hs-collapse-toggle p-2 inline-flex justify-center items-center gap-2 rounded-lg border font-medium bg-white text-gray-700 shadow-sm align-middle hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-white focus:ring-blue-600 transition-all text-sm" data-hs-collapse="#navbar-collapse-with-animation" aria-controls="navbar-collapse-with-animation" aria-label="Toggle navigation">
          <svg class="hs-collapse-open:hidden flex-shrink-0 size-4" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" x2="21" y1="6" y2="6"/><line x1="3" x2="21" y1="12" y2="12"/><line x1="3" x2="21" y1="18" y2="18"/></svg>
          <svg class="hs-collapse-open:block hidden flex-shrink-0 size-4" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
        </button>
      </div>
    </div>
    <div id="navbar-collapse-with-animation" class="hs-collapse hidden overflow-hidden transition-all duration-300 basis-full grow sm:block">
      <div class="flex flex-col gap-y-4 gap-x-0 mt-5 sm:flex-row sm:items-center sm:justify-end sm:gap-y-0 sm:gap-x-7 sm:mt-0 sm:ps-7">
        {navItems.map(item => (
          <div class="hs-dropdown relative inline-flex">
            <a class="font-medium text-gray-500 hover:text-gray-400 sm:py-6" href={item.href}>{item.text}</a>
            {item.submenu && (
              <div class="hs-dropdown-menu transition-[opacity,margin] duration hs-dropdown-open:opacity-100 opacity-0 hidden min-w-60 bg-white shadow-md rounded-lg p-2 mt-2" aria-labelledby="hs-dropdown-basic">
                {item.submenu.map(subItem => (
                  <a class="flex items-center gap-x-3.5 py-2 px-3 rounded-lg text-sm text-gray-800 hover:bg-gray-100 focus:ring-2 focus:ring-blue-500" href={subItem.href}>{subItem.text}</a>
                ))}
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  </nav>
</header>
\`\`\`

**EXAMPLE OF A GOOD ATOMIC HERO COMPONENT:**
\`\`\`astro
---
const heroTitle = "Find Your Dream Home";
const heroSubtitle = "Discover the perfect property with our expert guidance.";
const heroButtonText = "Get Started";
---
<section class="bg-gray-100 py-20">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
    <h1 class="text-4xl font-bold text-gray-900">{heroTitle}</h1>
    <p class="mt-4 text-lg text-gray-600">{heroSubtitle}</p>
    <a href="#features" class="mt-8 inline-block bg-blue-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-blue-700">{heroButtonText}</a>
    <img src={heroImage} alt={heroAltText} class="mt-10 w-full h-auto rounded-lg shadow-lg" />
  </div>
</section>
\`\`\`
`;

// === ABSTRACT PIPELINE DEDICATED CONSTANTS ===
const ABSTRACT_MAX_RETRIES = 2;
const ABSTRACT_CODEGEN_SYSTEM_PROMPT = `You are a world-class AI developer specializing in creating production-ready Astro components using Tailwind CSS and Preline UI. Your code should be clean, semantic, and follow best practices.

**CRITICAL DIRECTIVES:**
1.  **ATOMIC COMPONENTS (STRICT):**
    *   **ONE SECTION ONLY:** Each component MUST contain ONLY its designated section. If creating a "Menu" component, it should contain ONLY the navigation/menu section. If creating a "Hero" component, it should contain ONLY the hero section. NEVER include multiple sections in a single component.
    *   **NO FULL PAGES:** Do NOT create complete landing pages with multiple sections. Each component is a building block that will be assembled into a complete page later.
    *   **NO HTML/HEAD/BODY:** Do NOT include <!DOCTYPE html>, <html>, <head>, or <body> tags. These are page-level elements, not component-level elements.

2.  **TECH STACK:**
    *   **Astro:** Generate a valid, single-file Astro component (.astro).
    *   **Tailwind CSS:** All styling MUST be done with Tailwind CSS utility classes.
    *   **Preline UI:** You MUST use Preline UI components (see https://preline.co/ for components like headers, dropdowns, cards, etc.) to create modern, professional-looking layouts. This is a strict requirement for design consistency.

3.  **IMAGES AND VISUAL CONTENT (CRITICAL):**
    *   **ALWAYS INCLUDE IMAGES:** Every component MUST include relevant images, icons, and visual elements. This is NOT optional.
    *   **Image Sources:** Use high-quality images from Freepik Stock Content API:
      - The system will automatically fetch images from Freepik API based on component type
      - For avatars, use local images from \`/images/avatars/\` folder
      - Use Lucide Astro icons for icons (import from \`@lucide/astro\`)
      - Font Awesome icons when needed
      - **IMPORTANT:** Use placeholder patterns like \`"path/to/image"\` for images - the system will automatically replace these with actual Freepik URLs
    *   **Image Types by Component:**
      - **Hero:** Background images, product images, lifestyle photos from Freepik
      - **Features:** Icons, product mockups, screenshots from Freepik
      - **Testimonials:** Avatar images, customer photos from Freepik
      - **Products:** Product images, mockups, lifestyle shots from Freepik
      - **Gallery:** Multiple high-quality images from Freepik
      - **About:** Team photos, office images, process diagrams from Freepik
    *   **Image Optimization:** Always include \`alt\` attributes and responsive sizing
    *   **Visual Hierarchy:** Use images to create visual interest and guide user attention

4.  **CODE QUALITY:**
    *   **Correct Tag Usage:** You MUST use the correct, top-level semantic HTML tag. For example, a component named \`Footer\` MUST use a \`<footer>\` tag, not \`<header>\`. A component named \`Testimonial\` or \`Hero\` should use a \`<section>\` tag.
    *   **Semantic HTML:** Use appropriate HTML5 tags like \`<header>\`, \`<nav>\`, \`<section>\`, \`<figure>\`, etc. For a navigation bar, use \`<header>\` and \`<nav>\`.
    *   **Data Separation (Strict):** You MUST separate content from presentation. ALL text content (headings, paragraphs, button text, labels, etc.), link URLs, and lists of items MUST be defined as constants in the \`---\` frontmatter. The HTML body must then reference these variables. **There are no exceptions to this rule; do not hardcode ANY text directly in the HTML body.**
    *   **Dynamic & Reusable:** Avoid hardcoding content. For navigation links, generate anchor links (e.g., \`href="#faq"\`) based on the item name. For logos or brand names, use a generic placeholder like "Logo" or "Brand Name" that is easy for the user to replace.
    *   **Production-Ready:** The generated component must be complete and ready to use. No "Lorem Ipsum" or unfinished parts.

5.  **NAVIGATION COMPONENTS:**
    *   **Structure:** Navigation items MUST be defined as an array in the frontmatter with all properties (text, href, submenu items).
    *   **Layout:** Follow the user's layout instructions exactly (e.g., "logo on left, items on right").
    *   **Submenus:** If a menu item has submenus, use Preline's dropdown component (\`hs-dropdown\`) and nest the submenu items properly.
    *   **Mobile:** Always include a mobile-responsive hamburger menu using Preline's collapse component.

6.  **COMPONENT STRUCTURE:**
    *   Only include a \`---\` frontmatter section if you need to define props or import something. Keep it minimal. Most components should not need it.

7.  **RESPONSE FORMAT:**
    *   Your response MUST be ONLY the raw Astro code. No explanations, no markdown, no apologies. Just the code.

**EXAMPLE OF A GOOD ATOMIC MENU COMPONENT:**
\`\`\`astro
---
const navItems = [
  { text: "Home", href: "#home" },
  { text: "Features", href: "#features", submenu: [
    { text: "Core Features", href: "#core-features" },
    { text: "Advanced", href: "#advanced" }
  ]},
  { text: "Pricing", href: "#pricing" }
];

const brandName = "Your Brand";
---
<header class="flex flex-wrap sm:justify-start sm:flex-nowrap z-50 w-full bg-white text-sm py-3 sm:py-0">
  <nav class="relative max-w-7xl w-full mx-auto px-4 sm:flex sm:items-center sm:justify-between sm:px-6 lg:px-8" aria-label="Global">
    <div class="flex items-center justify-between">
      <a class="flex-none text-xl font-semibold" href="#" aria-label="Brand">{brandName}</a>
      <div class="sm:hidden">
        <button type="button" class="hs-collapse-toggle p-2 inline-flex justify-center items-center gap-2 rounded-lg border font-medium bg-white text-gray-700 shadow-sm align-middle hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-white focus:ring-blue-600 transition-all text-sm" data-hs-collapse="#navbar-collapse-with-animation" aria-controls="navbar-collapse-with-animation" aria-label="Toggle navigation">
          <svg class="hs-collapse-open:hidden flex-shrink-0 size-4" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" x2="21" y1="6" y2="6"/><line x1="3" x2="21" y1="12" y2="12"/><line x1="3" x2="21" y1="18" y2="18"/></svg>
          <svg class="hs-collapse-open:block hidden flex-shrink-0 size-4" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
        </button>
      </div>
    </div>
    <div id="navbar-collapse-with-animation" class="hs-collapse hidden overflow-hidden transition-all duration-300 basis-full grow sm:block">
      <div class="flex flex-col gap-y-4 gap-x-0 mt-5 sm:flex-row sm:items-center sm:justify-end sm:gap-y-0 sm:gap-x-7 sm:mt-0 sm:ps-7">
        {navItems.map(item => (
          <div class="hs-dropdown relative inline-flex">
            <a class="font-medium text-gray-500 hover:text-gray-400 sm:py-6" href={item.href}>{item.text}</a>
            {item.submenu && (
              <div class="hs-dropdown-menu transition-[opacity,margin] duration hs-dropdown-open:opacity-100 opacity-0 hidden min-w-60 bg-white shadow-md rounded-lg p-2 mt-2" aria-labelledby="hs-dropdown-basic">
                {item.submenu.map(subItem => (
                  <a class="flex items-center gap-x-3.5 py-2 px-3 rounded-lg text-sm text-gray-800 hover:bg-gray-100 focus:ring-2 focus:ring-blue-500" href={subItem.href}>{subItem.text}</a>
                ))}
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  </nav>
</header>
\`\`\`

**EXAMPLE OF A GOOD ATOMIC HERO COMPONENT:**
\`\`\`astro
---
const heroTitle = "Find Your Dream Home";
const heroSubtitle = "Discover the perfect property with our expert guidance.";
const heroButtonText = "Get Started";
---
<section class="bg-gray-100 py-20">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
    <h1 class="text-4xl font-bold text-gray-900">{heroTitle}</h1>
    <p class="mt-4 text-lg text-gray-600">{heroSubtitle}</p>
    <a href="#features" class="mt-8 inline-block bg-blue-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-blue-700">{heroButtonText}</a>
    <img src={heroImage} alt={heroAltText} class="mt-10 w-full h-auto rounded-lg shadow-lg" />
  </div>
</section>
\`\`\`
`;

// === GENERIC PIPELINE DEDICATED FUNCTIONS ===
// Generic pipeline dedicated directory functions (completely independent)
function getGenericComponentsDir(subpath: string = ''): string {
  // Generic pipeline uses its own directory logic - goes up one level from /interface to project root
  const genericProjectRoot = path.resolve(process.cwd(), '..');
  return path.join(genericProjectRoot, 'rendering', 'src', 'components', subpath);
}

function getGenericPagesDir(subpath: string = ''): string {
  // Generic pipeline uses its own directory logic - goes up one level from /interface to project root
  const genericProjectRoot = path.resolve(process.cwd(), '..');
  return path.join(genericProjectRoot, 'rendering', 'src', 'pages', subpath);
}

// Generic pipeline dedicated function to sanitize component names for safe file names
function sanitizeGenericComponentName(componentName: string): string {
  return componentName
    .replace(/\s+/g, '') // Remove all spaces first
    .replace(/[^a-zA-Z0-9]/g, '') // Remove all non-alphanumeric characters
    .replace(/^([a-z])/, (match) => match.toUpperCase()) // Capitalize first letter
    .replace(/^([A-Z])/, (match) => match) // Keep first letter capitalized
    || 'Component'; // Fallback if empty
}

// Generic pipeline dedicated mockup image path function
async function getGenericMockupImagePath(prompt?: string, componentName?: string, requirements?: any): Promise<string> {
  // Use Unsplash API for dynamic images in Next.js runtime
  const { enhancedImageService } = await import('../services/image-service');
  return await enhancedImageService.getMockupImage(undefined, prompt, componentName, requirements);
}

// Generic pipeline dedicated video URL function with enhanced handling
async function getGenericVideoUrl(prompt?: string): Promise<string> {
  // Use Pexels API for dynamic videos
  const { pexelsVideoService } = await import('../services/pexels-video-api');
  
  try {
    // Test connection first
    const isConnected = await pexelsVideoService.testConnection();
    if (!isConnected) {
      console.warn('[GenericPipeline] ‚ö†Ô∏è Pexels API not available, using fallback videos');
      return '/images/videos/placeholder.mov'; // Use local fallback
    }

    // Extract theme from prompt for better video search
    let searchTerm = 'salon experience';
    if (prompt) {
      const themeKeywords = prompt.toLowerCase().match(/\b(?:salon|beauty|fashion|style|luxury|elegant|professional|auto|car|vehicle|parts|mechanical)\b/g);
      if (themeKeywords && themeKeywords.length > 0) {
        searchTerm = themeKeywords.join(' ');
      }
    }

    console.log('[GenericPipeline] üé• Fetching video for search term:', searchTerm);
    
    // Try to get video from Pexels with enhanced options
    const videoUrl = await pexelsVideoService.getRandomVideo(searchTerm, {
      orientation: 'landscape',
      size: 'medium',
      per_page: 10 // Request more videos for better selection
    });

    if (videoUrl && videoUrl !== '/images/videos/placeholder.mov') {
      console.log('[GenericPipeline] ‚úÖ Successfully fetched Pexels video');
      return videoUrl;
    } else {
      console.warn('[GenericPipeline] ‚ö†Ô∏è No Pexels video found, using local fallback');
      return '/images/videos/placeholder.mov';
    }
  } catch (error) {
    console.error('[GenericPipeline] ‚ùå Pexels API error:', error);
    console.log('[GenericPipeline] üîÑ Using local fallback video');
    return '/images/videos/placeholder.mov';
  }
}

// Generic pipeline dedicated avatar image path function
async function getGenericAvatarImagePath(): Promise<string> {
  // Fallback to local avatar images for Next.js runtime
  const localAvatars = [
    'Avatar_woman.avif',
    'Avatar_woman2.avif', 
    'Avatar_woman3.avif',
    'Avatar_woman4.avif',
    'Avatar_woman5.avif',
    'Avatar_man.avif',
    'Avatar_man2.avif',
    'Avatar_man3.avif',
    'Avatar_man4.avif',
    'Avatar_man6.avif',
    'Avatar_man7.avif'
  ];
  
  const selectedAvatar = localAvatars[Math.floor(Math.random() * localAvatars.length)];
  return `/images/avatars/${selectedAvatar}`;
}

// Generic pipeline dedicated index.astro update function
async function updateGenericIndexAstroWithSections(componentNames: string[]) {
  const pagesDir = getGenericPagesDir(); // Use Generic-specific directory function
  const indexPath = path.join(pagesDir, 'index.astro');
  let content = await fs.readFile(indexPath, 'utf-8');

  // Helper function to convert to PascalCase consistently
  const toPascalCase = (name: string): string => {
    return name
      .replace(/[^a-zA-Z0-9]+/g, ' ') // Replace non-alphanumeric with space
      .split(' ')
      .filter(Boolean)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join('');
  };

  // Remove all previous imports and SectionWrappers for these components
  for (const componentName of componentNames) {
    const sanitizedName = sanitizeGenericComponentName(componentName);
    const pascalName = toPascalCase(sanitizedName.replace('.astro', ''));
    const importRegex = new RegExp(`import ${pascalName} from ['"].*${pascalName}\.astro['"];?\n?`, 'g');
    content = content.replace(importRegex, '');
  }

  // Remove ALL existing SectionWrapper blocks to prevent duplicates
  content = content.replace(/<SectionWrapper[^>]*>[\s\S]*?<\/SectionWrapper>\s*/g, '');

  // Add imports for all components after the last import, avoiding duplicates
  const lastImportIndex = content.lastIndexOf('import');
  const endOfLastImport = content.indexOf('\n', lastImportIndex);
  let importBlock = '';
  const addedImports = new Set<string>(); // Track added imports to avoid duplicates
  
  for (const componentName of componentNames) {
    const sanitizedName = sanitizeGenericComponentName(componentName);
    const pascalName = toPascalCase(sanitizedName.replace('.astro', ''));
    
    // Only add import if not already present
    if (!addedImports.has(pascalName) && !content.includes(`import ${pascalName} from`)) {
      importBlock += `import ${pascalName} from '../components/${pascalName}.astro';\n`;
      addedImports.add(pascalName);
    }
  }
  
  content = content.slice(0, endOfLastImport + 1) + importBlock + content.slice(endOfLastImport + 1);

  // Add SectionWrappers for all components in order, before </main> or </body>
  let sectionBlock = '';
  for (const componentName of componentNames) {
    const sanitizedName = sanitizeGenericComponentName(componentName);
    const pascalName = toPascalCase(sanitizedName.replace('.astro', ''));
    // Use original component name for section ID (lowercase, replace spaces with hyphens)
    const sectionId = componentName.toLowerCase().replace(/\s+/g, '-');
    sectionBlock += `\n    <SectionWrapper id="${sectionId}">\n      <${pascalName} />\n    </SectionWrapper>\n`;
  }
  if (content.includes('</main>')) {
    content = content.replace('</main>', `${sectionBlock}\n</main>`);
  } else {
    content = content.replace('</body>', `${sectionBlock}\n</body>`);
  }

  await fs.writeFile(indexPath, content);
  console.log(`[TRACE][Generic] Updated index.astro to include all generated sections.`);
}

// ===============================
// PIPELINE: CREATE - SINGLE COMPONENT (Fully Independent)
// ===============================

/**
 * SingleComponentPipeline: Handles the 'Create: Single Component' pipeline.
 * This pipeline is 100% independent and does not share any logic with other pipelines.
 * It generates a single Astro component from a prompt.
 */
async function runSingleComponentPipeline({ componentName, prompt }: { componentName: string, prompt: string }): Promise<{ success: boolean; componentPath: string }> {
  console.log('=== [TRACE] Entered Single Component Create Pipeline ===');
  const componentDir = getGenericComponentsDir(); // Use Generic directory to avoid undefined single dir
  const filePath = path.join(componentDir, `${sanitizeGenericComponentName(componentName)}.astro`);

  console.log(`[TRACE][Single] Generating single component: ${componentName}`);

  // Inject domain security context into system prompt
  const systemPrompt = await DomainSecurityService.injectIntoSystemPrompt(SINGLE_CODEGEN_SYSTEM_PROMPT);
  
  // Always include SINGLE_CODEGEN_SYSTEM_PROMPT as the first message
  const response = await new Mistral({ apiKey: process.env.MISTRAL_API_KEY! }).chat.complete({
    model: 'codestral-2405',
    messages: [
      { role: 'system', content: systemPrompt }, // Use Single-specific system prompt with domain security
      { role: 'user', content: prompt }
    ],
    temperature: 0.1,
  });
  let generatedCode = response.choices[0].message.content;
  if (!generatedCode || typeof generatedCode !== 'string') {
    throw new Error('AI failed to generate valid string code for the component.');
  }
  let cleanedCode = generatedCode.replace(/```(astro)?/g, '').trim();
  const mockupPath = await getGenericMockupImagePath(prompt, componentName); // Use Generic mockup path
  // Replace various placeholder patterns with actual image URLs
  cleanedCode = cleanedCode.replace(/"([\/]?path[\/]to[\/]?[^\"]+)"/g, `"${mockupPath}"`); // Use Single-specific mockup path
  //cleanedCode = cleanedCode.replace(/"https:\/\/api\.freepik\.com\/images\/[^"]*"/g, `"${mockupPath}"`); // Replace Freepik placeholder URLs
  //cleanedCode = cleanedCode.replace(/"https:\/\/img\.freepik\.com\/[^"]*"/g, `"${mockupPath}"`); // Replace Freepik image URLs
  
  // Replace avatar placeholders with local avatar images
  const { enhancedImageService } = await import('../services/image-service');
  const avatarPath = await enhancedImageService.getAvatarImage();
  cleanedCode = cleanedCode.replace(/"path\/to\/avatar"/g, `"${avatarPath}"`);
  //cleanedCode = cleanedCode.replace(/"https:\/\/api\.freepik\.com\/images\/avatar\/[^"]*"/g, `"${avatarPath}"`);
  //cleanedCode = cleanedCode.replace(/"\/images\/avatars\/[^"]*\.jpg"/g, `"${avatarPath}"`); // Replace hardcoded jpg paths
  //cleanedCode = cleanedCode.replace(/"\/images\/avatars\/[^"]*\.png"/g, `"${avatarPath}"`); // Replace hardcoded png paths
  cleanedCode = cleanedCode.replace(/\skey=\{[^}]+\}/g, '');
  // Additional avatar path replacements for hardcoded paths
  //cleanedCode = cleanedCode.replace(/"\/images\/avatars\/[^"]*\.jpg"/g, `"${avatarPath}"`); // Replace hardcoded jpg paths
  //cleanedCode = cleanedCode.replace(/"\/images\/avatars\/[^"]*\.png"/g, `"${avatarPath}"`); // Replace hardcoded png paths
  cleanedCode = cleanedCode.replace(/<input([^>]*?)type=\{([^}]+)\}([^>]*)>/g, (match, before, typeExpr, after) => {
    return `<input${before}type={String(${typeExpr}) as HTMLInputTypeAttribute}${after}>`;
  });

  // Write the file first
  await fs.writeFile(filePath, cleanedCode);
  // === Only run validation/auto-fix if file is directly inside /rendering/src/components (not subfolders) ===
  const renderingComponentsDir = path.resolve(getGenericComponentsDir());
  const fileAbsPath = path.resolve(filePath);
  const fileParentDir = path.dirname(fileAbsPath);
  console.log(`[DEBUG] file: ${fileAbsPath}, parent: ${fileParentDir}, target: ${renderingComponentsDir}`);
  let shouldUpdateIndex = false;
  if (fileParentDir === renderingComponentsDir) {
    // const fileContent = await fs.readFile(filePath, 'utf-8');
    // === FULLY COMMENTED OUT: NO VALIDATION OR AUTO-FIX FOR SINGLE MODE CREATION ===
    // const { isValid, error } = await SingleAstroValidator.compileAstro(fileContent, renderingComponentsDir);
    // if (!isValid) {
    //   console.log(`[SingleComponentPipeline] Real error detected in new component, running auto-fix for: ${filePath}`);
    //   const validatedCode = await SingleAstroValidator.validateAndFix(fileContent, renderingComponentsDir);
    //   await fs.writeFile(filePath, validatedCode);
    //   console.log(`[SingleComponentPipeline] Astro validation/auto-fix applied to: ${filePath}`);
    // } else {
    //   console.log(`[SingleComponentPipeline] No real errors detected, skipping auto-fix for: ${filePath}`);
    // }
    shouldUpdateIndex = true;
  } else {
    // Strict: never validate or auto-fix any other files
    console.log(`[SKIP][SingleComponentPipeline] Not validating: ${fileAbsPath} (parent: ${fileParentDir}, only validate new file in /rendering/src/components root)`);
  }
  if (shouldUpdateIndex) {
    await updateGenericIndexAstroWithSections([componentName]);
    console.log(`[TRACE][Single] Updated index.astro with ${componentName} (single pipeline logic)`);
  } else {
    console.log(`[TRACE][Single] Skipped index.astro update due to not being in root components dir for: ${componentName}`);
  }
  console.log(`[TRACE][Single] Created and validated component: ${filePath}`);
  console.log('=== [TRACE] Exiting Single Component Create Pipeline ===');
  return { success: true, componentPath: filePath };
}

// ===============================
// PIPELINE: CREATE - ABSTRACT (Fully Independent)
// ===============================

interface CreateAbstractInstructions {
  componentNames: string[];
  prompt: string;
}

/**
 * AbstractCreatePipeline: Handles the 'Create: Abstract' pipeline.
 * This pipeline is 100% independent and does not share any logic with other pipelines.
 * It generates multiple atomic sections/components from a single prompt using dataset examples.
 */
async function runAbstractCreatePipeline({ componentNames, prompt }: CreateAbstractInstructions): Promise<{ success: boolean; componentPaths: string[] }> {
  console.log('=== [TRACE] Entered Abstract Create Pipeline ===');
  const componentDir = getGenericComponentsDir();
  const createdPaths: string[] = [];

  for (const componentName of componentNames) {
    console.log(`[TRACE][Abstract] Generating atomic section: ${componentName}`);
    
    // === ENHANCE PROMPT WITH UI DATASET EXAMPLES ===
    const basePrompt = `Create ONLY the ${componentName} section as a single, production-ready Astro component named '${componentName}'. Do NOT include any other sections or unrelated content. Do NOT include a full page. Only the ${componentName} section.\n\nUSER INSTRUCTIONS: ${prompt}`;
    
    const enhancedPrompt = await PromptEnhancer.enhanceComponentPrompt(componentName, basePrompt);
    console.log(`[TRACE][Abstract] Enhanced prompt for ${componentName} with ${enhancedPrompt.examplesUsed} UI examples`);
    
    const response = await mistralClient.chat.complete({
      model: 'codestral-2405',
      messages: [
        { role: 'system', content: ABSTRACT_CODEGEN_SYSTEM_PROMPT }, // Use Abstract-specific system prompt
        { role: 'user', content: enhancedPrompt.enhancedPrompt }
      ],
      temperature: 0.1,
    });
    let generatedCode = response.choices[0].message.content;
    if (!generatedCode || typeof generatedCode !== 'string') {
      throw new Error(`AI failed to generate valid string code for the component: ${componentName}`);
    }
      let cleanedCode = generatedCode.replace(/```(astro)?/g, '').trim();
  const mockupPath = await getGenericMockupImagePath(prompt, componentName);
  // Replace various placeholder patterns with actual image URLs
  cleanedCode = cleanedCode.replace(/"([\/]?path[\/]to[\/]?[^\"]+)"/g, `"${mockupPath}"`); // Use Abstract-specific mockup path
  cleanedCode = cleanedCode.replace(/"https:\/\/api\.freepik\.com\/images\/[^"]*"/g, `"${mockupPath}"`); // Replace Freepik placeholder URLs
  cleanedCode = cleanedCode.replace(/"https:\/\/img\.freepik\.com\/[^"]*"/g, `"${mockupPath}"`); // Replace Freepik image URLs
  
  // Replace avatar placeholders with local avatar images
  const { enhancedImageService } = await import('../services/image-service');
  const avatarPath = await enhancedImageService.getAvatarImage();
  cleanedCode = cleanedCode.replace(/"path\/to\/avatar"/g, `"${avatarPath}"`);
  cleanedCode = cleanedCode.replace(/"https:\/\/api\.freepik\.com\/images\/avatar\/[^"]*"/g, `"${avatarPath}"`);
  cleanedCode = cleanedCode.replace(/\skey=\{[^}]+\}/g, '');
    cleanedCode = cleanedCode.replace(/<input([^>]*?)type=\{([^}]+)\}([^>]*)>/g, (match, before, typeExpr, after) => {
      return `<input${before}type={String(${typeExpr}) as HTMLInputTypeAttribute}${after}>`;
    });
    const filePath = path.join(componentDir, `${sanitizeGenericComponentName(componentName)}.astro`);
    // === Write the file FIRST ===
    await fs.writeFile(filePath, cleanedCode);
    // === Only run validation/auto-fix if file is directly inside /rendering/src/components (not subfolders) ===
    const renderingComponentsDir = path.resolve(getGenericComponentsDir());
    const fileAbsPath = path.resolve(filePath);
    const fileParentDir = path.dirname(fileAbsPath);
    console.log(`[DEBUG] file: ${fileAbsPath}, parent: ${fileParentDir}, target: ${renderingComponentsDir}`);
    if (fileParentDir === renderingComponentsDir) {
      // const fileContent = await fs.readFile(filePath, 'utf-8');
      // const validatedCode = await AbstractAstroValidator.validateAndFix(fileContent, renderingComponentsDir);
      // await fs.writeFile(filePath, validatedCode);
      // console.log(`[CreateAbstractPipeline] Astro validation/auto-fix applied to: ${filePath}`);
      // [AUTO-FIX DISABLED BY USER REQUEST]
    } else {
      console.log(`[SKIP] Not validating: ${fileAbsPath} (parent: ${fileParentDir})`);
    }
    createdPaths.push(filePath);
    console.log(`[TRACE][Abstract] Created and validated component: ${filePath}`);
  }
  // After all components are created, update index.astro using Abstract-specific function
  await updateGenericIndexAstroWithSections(componentNames);
  console.log('=== [TRACE] Exiting Abstract Create Pipeline ===');
  return { success: true, componentPaths: createdPaths };
}

// ===============================
// MAIN PIPELINE ROUTER
// ===============================

/**
 * Main handler for the 'generate-file' tool. Routes to the correct pipeline based on instructions.mode.
 */
export async function executeGenerateFile(instructions: GenerateFileInstructions & { position?: string, layout?: string }): Promise<{ success: boolean; componentPath?: string; componentPaths?: string[] }> {
  console.log('=== [TRACE] Main Pipeline Router: executeGenerateFile ===');
  // Pipeline router
  if (instructions.mode === 'abstract') {
    console.log('[TRACE] Routing to Abstract Create Pipeline');
    // Abstract pipeline: expects componentNames[] and prompt
    if (!instructions.componentNames || !Array.isArray(instructions.componentNames)) {
      throw new Error('Abstract mode requires componentNames array.');
    }
    // Use the fully independent Abstract pipeline
    return await runAbstractCreatePipeline({
      componentNames: instructions.componentNames,
      prompt: instructions.originalPrompt || instructions.generationPrompt,
    });
  }
  if (instructions.mode === 'vision') {
    console.log('[TRACE] Routing to Vision Create Pipeline');
    // Vision pipeline: expects componentName and prompt
    if (!instructions.componentName) {
      throw new Error('Vision mode requires componentName.');
    }
    // Pass layout and position if available (from orchestrator)
    return await runVisionPipeline({
      componentName: instructions.componentName,
      prompt: instructions.originalPrompt || instructions.generationPrompt,
      position: instructions.position,
      layout: instructions.layout
    });
  }
  if (instructions.mode === 'generic') {
    console.log('[TRACE] Routing to Generic Create Pipeline');
    // Generic pipeline: expects componentNames[] and prompt
    if (!instructions.componentNames || !Array.isArray(instructions.componentNames)) {
      throw new Error('Generic mode requires componentNames array.');
    }
    // Use the fully independent Generic pipeline
    const genericResult = await runGenericCreatePipeline({
      componentNames: instructions.componentNames,
      prompt: instructions.originalPrompt || instructions.generationPrompt,
    });
    if (!genericResult) {
      throw new Error('Generic pipeline failed with no result');
    }
    return genericResult;
  }
  if (instructions.mode === 'single' || (!instructions.mode && instructions.componentName)) {
    console.log('[TRACE] Routing to Single Component Create Pipeline');
    // Single component pipeline: expects componentName and prompt
    return await runSingleComponentPipeline({
      componentName: instructions.componentName,
      prompt: instructions.originalPrompt || instructions.generationPrompt,
    });
  }
  // Default: fallback to legacy single-component creation
  try {
    const componentPath = await runSingleComponentPipeline({
      componentName: instructions.componentName,
      prompt: instructions.generationPrompt,
    });
    // Note: updateIndexPage function was removed, using updateIndexAstroWithSections instead
    // await updateIndexPage(instructions.componentName, instructions.originalPrompt);
    return { success: true, componentPath: componentPath.componentPath };
  } catch (error) {
    console.error(`[generateFileHandler] Error creating component ${instructions.componentName}:`, error);
    throw new Error(`Failed to generate component ${instructions.componentName}.`);
  }
}

// ===============================
// PIPELINE: CREATE - VISION (Fully Independent)
// ===============================

/**
 * VisionPipeline: Handles the 'Create: Vision' pipeline.
 * This pipeline is 100% independent and does not share any logic with other pipelines.
 * It generates a component from a visual (image) input, using AI vision and codegen.
 */
async function runVisionPipeline({ componentName, prompt, position = '', layout = '' }: { componentName: string, prompt: string, position?: string, layout?: string }): Promise<{ success: boolean; componentPath: string }> {
  console.log('=== [TRACE] Entered Vision Create Pipeline ===');
  // Call the vision creator handler (do not share logic with other pipelines)
  // The layout param is expected to be a base64 image string (from orchestrator)
  // The prompt is passed for context, but the vision handler uses the image and componentName
  try {
    // Call the vision creator
    const result = await executeVisionCreator({
      componentName,
      position,
      imageUrl: layout
    });
    if (!result.success || !result.filePath) {
      throw new Error(result.error || 'Vision pipeline failed to create component.');
    }
    console.log(`[VisionPipeline] Created and validated component: ${result.filePath}`);
    return { success: true, componentPath: result.filePath };
  } catch (error) {
    console.error(`[VisionPipeline] Error:`, error);
    throw error;
  }
}

// ===============================
// PIPELINE: CREATE - GENERIC (Fully Independent)
// ===============================

interface CreateGenericInstructions {
  componentNames: string[];
  prompt: string;
}

// Function to read test context file
async function getTestContext(): Promise<string> {
  try {
    const testContextPath = path.join(process.cwd(), 'lib', 'context', 'test.context');
    const testContext = await fs.readFile(testContextPath, 'utf-8');
    return testContext;
  } catch (error) {
    console.log('\x1b[35m[TEST CONTEXT] Could not read test.context file, proceeding without it\x1b[0m');
    return '';
  }
}

// Function to check if prompt contains fashion boutique keywords
function isFashionBoutiquePrompt(prompt: string): boolean {
  const fashionKeywords = ['fashion boutique', 'fashion', 'boutique', 'clothing', 'apparel', 'style', 'fashion store'];
  const lowerPrompt = prompt.toLowerCase();
  return fashionKeywords.some(keyword => lowerPrompt.includes(keyword));
}

/**
 * GenericPipeline: Handles the 'Create: Generic' pipeline.
 * This pipeline is 100% independent and does not share any logic with other pipelines.
 * It generates multiple atomic sections/components from a single prompt without using dataset examples.
 * ENHANCED: Now includes IRL, feedback learning, and conversational recovery.
 */
async function runGenericCreatePipeline({ componentNames, prompt }: CreateGenericInstructions): Promise<{ success: boolean; componentPaths: string[] } | undefined> {
  console.log('üå∏ [GenericPipeline] === STARTING ENHANCED GENERIC CREATE PIPELINE ===');
  console.log('üå∏ [GenericPipeline] Component names:', componentNames);
  console.log('üå∏ [GenericPipeline] Prompt:', prompt);
  
  // === INTELLIGENT ORCHESTRATION SERVICES (RESTORED) ===
  const irlService = new IRLService();
  const feedbackService = new FeedbackLearningService();
  const recoveryService = new ConversationalRecoveryService();
  
  const componentsDir = getGenericComponentsDir();
  console.log('üå∏ [GenericPipeline] Components directory:', componentsDir);
  
  // === SIMPLE THEME DETECTION ===
  console.log('üå∏ [GenericPipeline] Extracting theme once for all components...');
  // const theme = enhancedImageService.extractThemeFromPrompt(prompt); // COMMENTED OUT - Image service should only run during Astro component building
  const theme = 'general'; // Fallback to a generic theme for Next.js runtime
  console.log('üå∏ [GenericPipeline] Theme detected once:', theme);
  
  // === ENHANCED INTENT DETECTION WITH IMPROVED RAG ===
  console.log('üå∏ [GenericPipeline] Starting enhanced intent detection...');
  
  let structuredIntent: UserIntent;
  
  try {
    // Use the improved intent detection service
    const intentResult = await IntentDetectionService.detectIntent(prompt);
    
    if (intentResult.success && intentResult.intent) {
      structuredIntent = intentResult.intent;
      console.log('üå∏ [GenericPipeline] Enhanced intent detection successful:', {
        intent: structuredIntent.intent,
        confidence: intentResult.confidence,
        sections: structuredIntent.slots?.sections,
        businessType: structuredIntent.slots?.business_type,
        sectionDescriptions: structuredIntent.slots?.section_descriptions
      });
    } else {
      // Fallback to basic intent detection
      console.log('üå∏ [GenericPipeline] Using fallback intent detection...');
      structuredIntent = {
    intent: 'create_website',
    slots: {
      site_type: 'landing_page',
      sections: componentNames,
      business_type: theme,
      theme: 'modern',
      colors: [],
      features: []
    },
    confidence: 0.8,
    raw_prompt: prompt,
    extracted_sections: componentNames
  };
    }
  } catch (error) {
    console.warn('üå∏ [GenericPipeline] Intent detection failed, using fallback:', error);
    structuredIntent = {
      intent: 'create_website',
      slots: {
        site_type: 'landing_page',
        sections: componentNames,
        business_type: theme,
        theme: 'modern',
        colors: [],
        features: []
      },
      confidence: 0.8,
      raw_prompt: prompt,
      extracted_sections: componentNames
    };
  }
  
  // === IRL TRANSFORMATION ===
  console.log('üå∏ [GenericPipeline] Creating intermediate representation...');
  const irlStructure = irlService.fromUserIntent(structuredIntent);
  
  // === VALIDATION AND LEARNING ===
  console.log('üå∏ [GenericPipeline] Validating IRL structure...');
  const validation = irlService.validateStructure(irlStructure);
  if (!validation.isValid) {
    console.warn('üå∏ [GenericPipeline] IRL validation warnings:', validation.warnings);
  }
  
  const generatedComponents: string[] = [];
  
  // Initialize knowledge base once for all components
  const knowledgeBase = ComponentKnowledgeBase.getInstance();
  console.log('üå∏ [GenericPipeline] Knowledge base initialized for all components');
  
  for (const componentName of componentNames) {
    console.log('üå∏ [GenericPipeline] === GENERATING COMPONENT:', componentName, '===');
    const filePath = path.join(componentsDir, `${componentName}.astro`);
    console.log('üå∏ [GenericPipeline] File path:', filePath);
    
    // === ENHANCED RAG & KNOWLEDGE BASE INTEGRATION ===
    console.log('üå∏ [GenericPipeline] Starting enhanced RAG & knowledge base integration...');
    
    let componentRequirements = `Generate a ${componentName} component for a ${theme} landing page`;
    
    try {
      
      // Step 2: Enhanced RAG with knowledge base integration
      const { RAGAgent } = await import('../agents/rag-agent');
      const ragAgent = new RAGAgent();
      
      console.log('üå∏ [GenericPipeline] Retrieving similar patterns via enhanced RAG...');
      console.log('üå∏ [GenericPipeline] Prompt for RAG:', prompt ? prompt.substring(0, 100) + '...' : 'undefined');
      console.log('üå∏ [GenericPipeline] ComponentName for RAG:', componentName);
      
      // CRITICAL FIX: Ensure we have valid inputs for RAG
      const ragPrompt = prompt || `Generate ${componentName} component`;
      const ragComponentName = componentName && typeof componentName === 'string' && componentName.trim().length > 0 
        ? componentName.trim() 
        : 'Component';
      
      const ragResult = await ragAgent.retrieveRelevantPatterns(ragPrompt, ragComponentName);
      
      if (ragResult.patterns.length > 0) {
        console.log('üå∏ [GenericPipeline] Found', ragResult.patterns.length, 'similar patterns');
        console.log('üå∏ [GenericPipeline] RAG confidence:', ragResult.confidence);
        
        // Step 3: Get section descriptions from intent detection
        const sectionDescriptions = structuredIntent.slots?.section_descriptions || {};
        const componentDescription = sectionDescriptions[componentName] || '';
        
        // Step 4: Enhanced requirements with RAG insights and section descriptions
        const enhancedRequirements = [
          `Generate a ${componentName} component for a ${theme} landing page`,
          componentDescription ? `Specific requirements: ${componentDescription}` : '',
          `Based on similar successful patterns:`,
          ...ragResult.recommendations,
          `Key features to include:`,
          ...ragResult.patterns.slice(0, 3).map(p => `- ${p.userRequest}`)
        ].filter(Boolean).join('\n');
        
        componentRequirements = enhancedRequirements;
        console.log('üå∏ [GenericPipeline] Enhanced requirements created with RAG + section descriptions');
        console.log('üå∏ [GenericPipeline] Component description found:', !!componentDescription);
      } else {
        console.log('üå∏ [GenericPipeline] No similar patterns found, using basic requirements');
        
        // Still use section descriptions if available
        const sectionDescriptions = structuredIntent.slots?.section_descriptions || {};
        const componentDescription = sectionDescriptions[componentName] || '';
        
        if (componentDescription) {
          componentRequirements = `${componentRequirements}\n\nSpecific requirements: ${componentDescription}`;
          console.log('üå∏ [GenericPipeline] Added section description to basic requirements');
        }
      }
      
      // Step 2: Use Multi-Agent Orchestration for further enhancement
      console.log('üå∏ [GenericPipeline] Starting intelligent multi-agent orchestration...');
      
      const { OrchestratorAgent } = await import('../agents/orchestrator-agent');
      const orchestrator = new OrchestratorAgent();
      
      // Create intelligent orchestration plan
      const plan = await orchestrator.createOrchestrationPlan(prompt);
      console.log('üå∏ [GenericPipeline] Orchestration plan created:', {
        tasks: plan.tasks?.length || 0,
        estimatedTime: plan.estimatedTime,
        confidence: plan.confidence
      });
      
      // Execute the plan (WITHOUT VALIDATION AGENT)
      const results = await orchestrator.executePlan(plan, prompt);
      console.log('üå∏ [GenericPipeline] Orchestration completed:', {
        successfulTasks: results.filter(r => r.success).length,
        totalTasks: results.length
      });
      
      // Extract component requirements from results and combine with RAG
      const requirementsResult = results.find(r => r.metadata?.agentType === 'requirements');
      if (requirementsResult?.data) {
        componentRequirements = `${componentRequirements}\n\nAdditional requirements from orchestration:\n${requirementsResult.data}`;
      }
      console.log('üå∏ [GenericPipeline] Combined RAG + orchestration requirements extracted');
      
      // Step 3: Knowledge base pattern learning
      console.log('üå∏ [GenericPipeline] Learning patterns for future use...');
      try {
        // Store the enhanced requirements for future learning
        await knowledgeBase.addPattern({
          id: `${componentName}-enhanced-${Date.now()}`,
          componentName,
          userRequest: prompt,
          requirements: componentRequirements,
          generatedCode: 'PENDING_GENERATION',
          success: true,
          feedback: 'Enhanced with RAG and section descriptions',
          timestamp: new Date()
        });
        console.log('üå∏ [GenericPipeline] Enhanced pattern stored for learning');
      } catch (learningError) {
        console.warn('üå∏ [GenericPipeline] Pattern learning failed:', learningError);
      }
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.warn('üå∏ [GenericPipeline] ‚ö†Ô∏è RAG/Orchestration failed, using fallback:', errorMessage);
      // Use fallback requirements extraction
      componentRequirements = await irlService.extractComponentRequirements(irlStructure, componentName, prompt);
      console.log('üå∏ [GenericPipeline] Fallback requirements extracted:', componentRequirements.length, 'characters');
    }
    
    // === SIMPLE DIRECT GENERATION (WORKING VERSION) ===
    console.log('üå∏ [GenericPipeline] Sending request to Codestral...');
    
    let generatedCode = '';
    
    try {
    // === DYNAMIC PROMPT GENERATION ===
    console.log('üå∏ [GenericPipeline] Generating dynamic prompts...');
    
    const systemPrompt = await dynamicPromptGenerator.generateSystemPrompt(componentName, prompt);
    const userPrompt = await dynamicPromptGenerator.generateUserPrompt(componentName, prompt, componentRequirements);
    
    console.log('üå∏ [GenericPipeline] Dynamic prompts generated successfully');
    
      const response = await mistralClient.chat.complete({
      model: 'codestral-2405',
      messages: [
        {
          role: 'system',
          content: systemPrompt
        },
        {
          role: 'user',
          content: userPrompt
        }
      ],
      temperature: 0.7,
    });
    
      console.log('üå∏ [GenericPipeline] Codestral response received');
      console.log('üå∏ [GenericPipeline] Response length:', response.choices[0]?.message?.content?.length || 0);
      
      const responseContent = response.choices[0]?.message?.content || '';
      generatedCode = Array.isArray(responseContent) ? responseContent.join('') : responseContent;
      console.log('üå∏ [GenericPipeline] Raw generated code length:', generatedCode.length);
    
    // Extract code from markdown if present
    const codeMatch = (generatedCode as string).match(/```(?:astro|html)?\s*\n([\s\S]*?)\n```/);
    if (codeMatch) {
      generatedCode = codeMatch[1];
        console.log('üå∏ [GenericPipeline] Extracted code from markdown, length:', generatedCode.length);
    }
    
    // Clean up the code
    generatedCode = (generatedCode as string).trim();
      console.log('üå∏ [GenericPipeline] Cleaned code length:', generatedCode.length);
    
    // === LINT ERROR FIXES ===
    console.log('üå∏ [GenericPipeline] Applying lint error fixes...');
    
    // Fix common Astro lint errors
    let fixedCode = generatedCode as string;
    
    // CRITICAL: Skip complex validation to prevent framework getting stuck
    console.log('üå∏ [GenericPipeline] Skipping complex validation to prevent framework getting stuck');
    
    // Remove React-specific key attributes from Astro map()
    fixedCode = fixedCode.replace(/key\s*=\s*\{[^}]+\}/g, '');
    
    // Remove className attributes (use class only)
    fixedCode = fixedCode.replace(/className\s*=\s*["'][^"']*["']/g, (match) => {
      return match.replace('className', 'class');
    });
    
    // Remove React-specific imports
    fixedCode = fixedCode.replace(/import\s+.*from\s+['"]react['"];?\s*\n?/g, '');
    fixedCode = fixedCode.replace(/import\s+.*from\s+['"]@lucide\/react['"];?\s*\n?/g, '');
    
    // Fix TypeScript interface declarations
    fixedCode = fixedCode.replace(/interface\s+(\w+)\s*\{/g, 'interface $1 {');
    
    // Remove any remaining React-specific syntax
    fixedCode = fixedCode.replace(/useState|useEffect|useRef/g, '');
    
    // Ensure proper Astro frontmatter structure
    if (!fixedCode.includes('---')) {
      fixedCode = `---
// ${componentName} Component
---

${fixedCode}`;
    }
    
    generatedCode = fixedCode;
    console.log('üå∏ [GenericPipeline] Lint fixes applied, code length:', generatedCode.length);
      
    } catch (error) {
      console.error('üå∏ [GenericPipeline] Codestral API error:', error);
      
      // Check if it's a rate limit error
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      if (errorMessage.includes('capacity exceeded') || errorMessage.includes('429')) {
        console.warn('üå∏ [GenericPipeline] Rate limit exceeded, using fallback generation...');
        
        // Use a simpler fallback generation with proper Astro structure
        generatedCode = `---
const title = "${componentName} Component";
const description = "This is a fallback ${componentName} component for ${theme}.";
---
<section class="bg-gray-100 py-20">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
    <h1 class="text-4xl font-bold text-gray-900">{title}</h1>
    <p class="mt-4 text-lg text-gray-600">{description}</p>
  </div>
</section>`;
        console.log('üå∏ [GenericPipeline] Using fallback code, length:', generatedCode.length);
      } else {
        // === ENHANCED RAG PATTERN LEARNING FOR FAILED GENERATION ===
        console.log('üå∏ [GenericPipeline] Learning from failed generation with enhanced RAG...');
        
        try {
          // Use the already initialized knowledge base
          const validUserRequest = prompt || `Generate ${componentName} component`;
          const validRequirements = typeof componentRequirements === 'string' ? componentRequirements : JSON.stringify(componentRequirements);
          
          // Get section descriptions for better learning
          const sectionDescriptions = structuredIntent.slots?.section_descriptions || {};
          const componentDescription = sectionDescriptions[componentName] || '';
          
          await knowledgeBase.addPattern({
            id: `${componentName}-failed-${Date.now()}`,
            componentName,
            userRequest: validUserRequest,
            requirements: validRequirements,
            generatedCode: 'FAILED_GENERATION',
            success: false,
            feedback: `Generation failed: ${errorMessage}. Section description: ${componentDescription}`,
            timestamp: new Date()
          });
          
          console.log('üå∏ [GenericPipeline] ‚ö†Ô∏è Enhanced failed pattern stored for learning');
          console.log('üå∏ [GenericPipeline] Section description included in learning:', !!componentDescription);
        } catch (learningError) {
          console.warn('üå∏ [GenericPipeline] ‚ö†Ô∏è Enhanced failed pattern learning failed:', learningError);
        }
        
        throw error; // Re-throw other errors
      }
    }
    
    // === SIMPLE IMAGE REPLACEMENT (WORKING VERSION) ===
    console.log('üå∏ [GenericPipeline] Starting simple image replacement...');
    
    // Get theme-aware mockup path
    console.log('üå∏ [GenericPipeline] Getting theme-aware mockup path...');
    // const mockupPath = await enhancedImageService.getMockupImage(undefined, prompt); // COMMENTED OUT - Image service should only run during Astro component building
    const mockupPath = await getGenericMockupImagePath(prompt, componentName); // Use local fallback
    console.log('üå∏ [GenericPipeline] Mockup path:', mockupPath);
    // Replace placeholders with actual images
    console.log('üå∏ [GenericPipeline] Replacing placeholders...');
    let cleanedCode = generatedCode.replace(/{{MOCKUP_IMAGE}}/g, mockupPath);
    
    // Fix the "undefined" issue - replace any "undefined" strings with actual values
    cleanedCode = cleanedCode.replace(/""undefined"/g, `"${mockupPath}"`);
    cleanedCode = cleanedCode.replace(/"undefined"/g, `"${mockupPath}"`);
    cleanedCode = cleanedCode.replace(/= ""undefined"/g, `= "${mockupPath}"`);
    cleanedCode = cleanedCode.replace(/= "undefined"/g, `= "${mockupPath}"`);
  
  // === RANDOM AVATAR REPLACEMENT ===
  // Replace {{AVATAR_IMAGE}} placeholders first
  const avatarPlaceholderMatches = cleanedCode.match(/{{AVATAR_IMAGE}}/g) || [];
  if (avatarPlaceholderMatches.length > 0) {
    const avatarPromises: Promise<string>[] = Array.from({ length: avatarPlaceholderMatches.length }, () => getGenericAvatarImagePath());
    const resolvedAvatars = await Promise.all(avatarPromises);
    let idx = 0;
    cleanedCode = cleanedCode.replace(/{{AVATAR_IMAGE}}/g, () => resolvedAvatars[idx++] || resolvedAvatars[0]);
  }
  
  // Replace any hard-coded avatar paths with random unique avatars
  const hardcodedAvatarRegex = /"(\/images\/avatars\/[^"']+\.avif|Avatar_[^"']+\.avif)"/g;
  const hardcodedMatches = cleanedCode.match(hardcodedAvatarRegex) || [];
  if (hardcodedMatches.length > 0) {
    const avatarPromises2: Promise<string>[] = Array.from({ length: hardcodedMatches.length }, () => getGenericAvatarImagePath());
    const resolvedAvatars = await Promise.all(avatarPromises2);
    let idx = 0;
    cleanedCode = cleanedCode.replace(hardcodedAvatarRegex, () => `"${resolvedAvatars[idx++] || resolvedAvatars[0]}"`);
  }
    // === ENHANCED VIDEO HANDLING ===
    console.log('üé¨ [GenericPipeline] Processing video placeholders...');
    const videoUrl = await getGenericVideoUrl(prompt);
    cleanedCode = cleanedCode.replace(/{{MOCKUP_VIDEO}}/g, videoUrl);
    cleanedCode = cleanedCode.replace(/{{VIDEO_URL}}/g, videoUrl);
    
    // Fix video "undefined" issues
    cleanedCode = cleanedCode.replace(/videoSrc\s*=\s*""undefined"/g, `videoSrc = "${videoUrl}"`);
    cleanedCode = cleanedCode.replace(/videoSrc\s*=\s*"undefined"/g, `videoSrc = "${videoUrl}"`);
    
    // === REPLACE HARDCODED VIDEO URLs WITH DYNAMIC PEXELS VIDEOS ===
    // Replace common hardcoded video URLs with dynamic Pexels videos
    const hardcodedVideoPatterns = [
      /videoSrc\s*=\s*["']https:\/\/assets\.mixkit\.co\/videos\/preview\/[^"']+["']/g,
      /videoSrc\s*=\s*["']https:\/\/[^"']+\.mp4["']/g,
      /src\s*=\s*["']https:\/\/assets\.mixkit\.co\/videos\/preview\/[^"']+["']/g,
      /src\s*=\s*["']https:\/\/[^"']+\.mp4["']/g
    ];
    
    for (const pattern of hardcodedVideoPatterns) {
      cleanedCode = cleanedCode.replace(pattern, `videoSrc = "${videoUrl}"`);
    }
    
    // Also replace any remaining hardcoded video URLs in video elements
    cleanedCode = cleanedCode.replace(
      /<source\s+src\s*=\s*["']https:\/\/[^"']+["']/g,
      `<source src="${videoUrl}"`
    );
    
    // Enhance video elements with proper Astro attributes
    cleanedCode = cleanedCode.replace(
      /<video([^>]*?)>/g,
      '<video$1 muted playsinline loop preload="metadata">'
    );
    
    // Fix malformed video attributes (remove duplicates and fix spacing)
    cleanedCode = cleanedCode.replace(
      /muted\s+muted\s+playsinline\s+loop\s+preload="metadata"/g,
      'muted playsinline loop preload="metadata"'
    );
    
    // Fix video elements with malformed attributes
    cleanedCode = cleanedCode.replace(
      /<video([^>]*?)\s+muted\s+playsinline\s+loop\s+preload="metadata"\s+>/g,
      '<video$1 muted playsinline loop preload="metadata">'
    );
    
    // Fix the specific malformed video attribute issue in Hero component
    cleanedCode = cleanedCode.replace(
      /<video([^>]*?)muted\s+playsinline\s+loop\s+preload="metadata">/g,
      '<video$1 muted playsinline loop preload="metadata">'
    );
    
    // Add fallback image for video elements
    cleanedCode = cleanedCode.replace(
      /(<video[^>]*>[\s\S]*?<\/video>)/g,
      (match, videoElement) => {
        // Extract poster attribute if it exists
        const posterMatch = videoElement.match(/poster\s*=\s*["']([^"']+)["']/);
        const posterUrl = posterMatch ? posterMatch[1] : mockupPath; // Use dynamic mockup image instead of hardcoded
        
        return `${videoElement}
        
        <!-- Fallback image if video fails to load -->
        <img 
          src="${posterUrl}" 
          alt="Video fallback" 
          class="w-full h-full object-cover hidden"
          style="display: none;"
        />`;
      }
    );
    
    // Add enhanced video loading script
    const videoScript = `
<script>
  // Enhanced video loading and error handling
  document.addEventListener('astro:page-load', () => {
    const video = document.querySelector('video') as HTMLVideoElement;
    const fallbackImage = document.querySelector('img[alt="Video fallback"]') as HTMLImageElement;
    
    if (video && fallbackImage) {
      // Handle video loading errors
      video.addEventListener('error', () => {
        console.log('üé¨ Video failed to load, showing fallback image');
        video.style.display = 'none';
        fallbackImage.style.display = 'block';
      });
      
      // Handle video loading success
      video.addEventListener('loadeddata', () => {
        console.log('üé¨ Video loaded successfully');
        fallbackImage.style.display = 'none';
      });
      
      // Handle video loading timeout
      setTimeout(() => {
        if (video.readyState === 0) {
          console.log('üé¨ Video loading timeout, showing fallback image');
          video.style.display = 'none';
          fallbackImage.style.display = 'block';
        }
      }, 5000); // 5 second timeout
    }
  });
</script>`;
    
    // Add video script if video element exists
    if (cleanedCode.includes('<video')) {
      cleanedCode += videoScript;
    }
    
    // === ENHANCED IMAGE REPLACEMENT - CATCH HARDCODED PATHS ===
    console.log('üå∏ [GenericPipeline] Replacing hardcoded image paths...');
    
    // Replace hardcoded fallback image URLs with dynamic ones
    cleanedCode = cleanedCode.replace(
      /src\s*=\s*["']https:\/\/images\.unsplash\.com\/photo-[^"']+["']/g,
      `src = "${mockupPath}"`
    );
    
    const avatarPathStatic = await getGenericAvatarImagePath();
    // Replace common hardcoded image patterns
    const imageReplacements = [
      // Hero images
      { pattern: /heroImage\s*=\s*["']path\/to\/hero-image["']/g, replacement: `heroImage = "${mockupPath}"` },
      { pattern: /heroImage\s*=\s*["']\/images\/hero\.jpg["']/g, replacement: `heroImage = "${mockupPath}"` },
      { pattern: /heroImage\s*=\s*["']\/images\/mockups\/.*\.jpg["']/g, replacement: `heroImage = "${mockupPath}"` },
      
      // General image paths
      { pattern: /src\s*=\s*["']path\/to\/.*image["']/g, replacement: `src = "${mockupPath}"` },
      { pattern: /src\s*=\s*["']\/images\/.*\.jpg["']/g, replacement: `src = "${mockupPath}"` },
      { pattern: /src\s*=\s*["']\/images\/.*\.png["']/g, replacement: `src = "${mockupPath}"` },
      
      // Alt text updates
      { pattern: /alt\s*=\s*["']Beautiful real estate property["']/g, replacement: `alt = "${theme} property from Unsplash"` },
      { pattern: /alt\s*=\s*["']Hero image["']/g, replacement: `alt = "${theme} property from Unsplash"` },
      
      // Avatar replacements
      { pattern: /avatar\s*=\s*["']\/images\/avatars\/.*\.avif["']/g, replacement: `avatar = "${avatarPathStatic}"` },
      { pattern: /image\s*=\s*["']\/images\/avatars\/.*\.avif["']/g, replacement: `image = "${avatarPathStatic}"` },
      { pattern: /avatar\s*=\s*["']Avatar_.*\.avif["']/g, replacement: `avatar = "${avatarPathStatic}"` },
      { pattern: /image\s*=\s*["']Avatar_.*\.avif["']/g, replacement: `image = "${avatarPathStatic}"` }
    ];
    
    for (const replacement of imageReplacements) {
      cleanedCode = cleanedCode.replace(replacement.pattern, replacement.replacement);
    }
    
    // Also replace any remaining hardcoded image URLs in JSX
    cleanedCode = cleanedCode.replace(/src\s*=\s*["']https:\/\/.*\.(jpg|png|jpeg|webp)["']/g, `src = "${mockupPath}"`);
    
    // Fix hardcoded avatar paths that are still showing up
    cleanedCode = cleanedCode.replace(
      /avatar\s*=\s*"\/images\/avatars\/Avatar_[^"]+\.avif"/g,
      `avatar = "${avatarPathStatic}"`
    );
    
    // Fix malformed URLs with double quotes (comprehensive fix)
    // cleanedCode = cleanedCode.replace(/""([^"]+)""/g, `"$1"`); // commented out duplicate fix
    // Updated malformed URL fix:
    cleanedCode = cleanedCode.replace(/""?https:[^"\s]+""?/g, (m) => `"${m.replace(/"/g, '')}"`);
    cleanedCode = cleanedCode.replace(/src\s*=\s*"([^"]+)"/g, `src = "$1"`);
    cleanedCode = cleanedCode.replace(/image\s*=\s*"([^"]+)"/g, `image = "$1"`);
    cleanedCode = cleanedCode.replace(/avatar\s*=\s*"([^"]+)"/g, `avatar = "$1"`);
    cleanedCode = cleanedCode.replace(/poster\s*=\s*"([^"]+)"/g, `poster = "$1"`);
    
    // Fix URLs in object properties (like in galleryItems array)
    cleanedCode = cleanedCode.replace(/src:\s*""([^"]+)""/g, `src: "$1"`);
    cleanedCode = cleanedCode.replace(/image:\s*""([^"]+)""/g, `image: "$1"`);
    cleanedCode = cleanedCode.replace(/avatar:\s*""([^"]+)""/g, `avatar: "$1"`);
    cleanedCode = cleanedCode.replace(/poster:\s*""([^"]+)""/g, `poster: "$1"`);
    
    // Fix URLs in object properties with different spacing
    cleanedCode = cleanedCode.replace(/src:\s*""([^"]+)""/g, `src: "$1"`);
    cleanedCode = cleanedCode.replace(/image:\s*""([^"]+)""/g, `image: "$1"`);
    cleanedCode = cleanedCode.replace(/avatar:\s*""([^"]+)""/g, `avatar: "$1"`);
    cleanedCode = cleanedCode.replace(/poster:\s*""([^"]+)""/g, `poster: "$1"`);
    
    // Fix URLs in object properties with no spacing
    cleanedCode = cleanedCode.replace(/src:""([^"]+)""/g, `src: "$1"`);
    cleanedCode = cleanedCode.replace(/image:""([^"]+)""/g, `image: "$1"`);
    cleanedCode = cleanedCode.replace(/avatar:""([^"]+)""/g, `avatar: "$1"`);
    cleanedCode = cleanedCode.replace(/poster:""([^"]+)""/g, `poster: "$1"`);
    
    // === GALLERY IMAGE UNIQUENESS FIX ===
    // Replace duplicate gallery images with unique ones based on ACTUAL content
    const galleryImageMatches = cleanedCode.match(/https:\/\/images\.unsplash\.com\/photo-[^"']+["']/g) || [];
    if (galleryImageMatches.length > 1) {
      console.log('üå∏ [GenericPipeline] Detected duplicate gallery images, generating unique ones based on content...');
      
      // Extract titles and descriptions from the component data
      const titleMatches = cleanedCode.match(/title:\s*["']([^"']+)["']/g) || [];
      const descriptionMatches = cleanedCode.match(/description:\s*["']([^"']+)["']/g) || [];
      
      // Combine titles and descriptions for unique search terms
      const searchTerms = [];
      for (let i = 0; i < Math.max(titleMatches.length, descriptionMatches.length); i++) {
        const title = titleMatches[i] ? titleMatches[i].replace(/title:\s*["']([^"']+)["']/, '$1') : '';
        const description = descriptionMatches[i] ? descriptionMatches[i].replace(/description:\s*["']([^"']+)["']/, '$1') : '';
        const combinedTerm = `${title} ${description}`.trim();
        if (combinedTerm) {
          searchTerms.push(combinedTerm);
        }
      }
      
      // Generate unique images for each gallery item based on their content
      const uniqueGalleryImages = await Promise.all(
        searchTerms.map(async (searchTerm, index) => {
          console.log(`üå∏ [GenericPipeline] Fetching unique image for: "${searchTerm}"`);
          return await getGenericMockupImagePath(prompt, componentName, { 
            content: { 
              elements: [{ 
                type: 'image', 
                description: searchTerm 
              }] 
            } 
          });
        })
      );
      
      // Replace each duplicate with a unique image based on content
      let idx = 0;
      cleanedCode = cleanedCode.replace(/https:\/\/images\.unsplash\.com\/photo-[^"']+["']/g, () => {
        const uniqueImage = uniqueGalleryImages[idx] || uniqueGalleryImages[0];
        idx++;
        return `"${uniqueImage}"`;
      });
    }
    
    console.log('üå∏ [GenericPipeline] Enhanced image replacement complete');
    console.log('üå∏ [GenericPipeline] Placeholders replaced, code length:', cleanedCode.length);
    
    // === NEW PLACEHOLDER REPLACEMENT SYSTEM ===
    console.log('üå∏ [GenericPipeline] Applying image placeholder replacement...');
    cleanedCode = await replaceImagePlaceholders(cleanedCode, componentName, prompt);
    
    // === CONSOLIDATE LUCIDE IMPORTS ===
    console.log('üå∏ [GenericPipeline] Consolidating Lucide imports...');
    
    // Find all Lucide imports and consolidate them
    const lucideImportRegex = /import\s+\{([^}]*)\}\s+from\s+['"]@lucide\/astro['"]/g;
    const lucideImports: string[] = [];
    let match;
    
    while ((match = lucideImportRegex.exec(cleanedCode)) !== null) {
      const icons = match[1].split(',').map(icon => icon.trim());
      lucideImports.push(...icons);
    }
    
    // Remove duplicate icons and create consolidated import
    const uniqueIcons = [...new Set(lucideImports)];
    if (uniqueIcons.length > 0) {
      const consolidatedImport = `import { ${uniqueIcons.join(', ')} } from '@lucide/astro';`;
      
      // Remove all existing Lucide imports completely
      cleanedCode = cleanedCode.replace(/import\s+\{[^}]*\}\s+from\s+['"]@lucide\/astro['"];?\s*\n?/g, '');
      
      // Clean up any empty lines that might be left
      cleanedCode = cleanedCode.replace(/\n\s*\n\s*\n/g, '\n\n');
      
      // Clean up any leftover semicolons from removed imports
      cleanedCode = cleanedCode.replace(/;\s*\n\s*;/g, '');
      cleanedCode = cleanedCode.replace(/;\s*\n\s*interface/g, '\ninterface');
      cleanedCode = cleanedCode.replace(/;\s*\n\s*const/g, '\nconst');
      cleanedCode = cleanedCode.replace(/;\s*\n\s*export/g, '\nexport');
      
      // Add consolidated import at the beginning of frontmatter
      const frontmatterMatch = cleanedCode.match(/^(---\s*\n)([\s\S]*?)(\n---\s*\n)/);
      if (frontmatterMatch) {
        const existingContent = frontmatterMatch[2].trim();
        const newContent = `${consolidatedImport}\n\n${existingContent}`;
        cleanedCode = cleanedCode.replace(frontmatterMatch[0], `${frontmatterMatch[1]}${newContent}${frontmatterMatch[3]}`);
      } else {
        // Create frontmatter if none exists
        cleanedCode = `---\n${consolidatedImport}\n---\n\n${cleanedCode}`;
      }
      
      console.log('üå∏ [GenericPipeline] ‚úÖ Consolidated Lucide imports:', uniqueIcons);
    }
    
    // === ENHANCED LUCIDE ICON HANDLING ===
    console.log('üå∏ [GenericPipeline] Starting enhanced Lucide icon handling...');
    
    // 100% DYNAMIC ICON HANDLING - NO STATIC MAPPING
    // CRITICAL LEARNING: Helper functions must return data objects, not JSX
    // This prevents "Expected '>' but found 'class'" errors in Astro components
    
    /**
     * Enhanced icon detection and import generation - 100% DYNAMIC
     */
    function detectAndGenerateIconImports(code: string): { imports: string[], iconUsage: string[] } {
      const iconUsage: string[] = [];
      const imports: Set<string> = new Set();
      
      // DYNAMIC APPROACH: Detect all Lucide icon usage patterns
      const iconPatterns = [
        // Direct Lucide icon component usage (e.g., <MapPin />, <Phone />, <Pill />)
        /<([A-Z][a-zA-Z]*)\s*(?:[^>]*)\/>/g,
        // Generic Icon component with name attribute
        /<Icon\s+name\s*=\s*["']([^"']+)["']/g,
        // Icon in object properties (e.g., icon: "twitter")
        /icon:\s*["']([^"']+)["']/g,
        /icon\s*=\s*["']([^"']+)["']/g
      ];
      
      // Common non-icon components to exclude
      const excludedComponents = [
        'Fragment', 'Component', 'Layout', 'Head', 'Script', 'Style', 
        'Slot', 'Astro', 'div', 'span', 'img', 'a', 'button', 'input',
        'form', 'section', 'header', 'footer', 'main', 'nav', 'aside',
        'article', 'figure', 'figcaption', 'ul', 'ol', 'li', 'p', 'h1',
        'h2', 'h3', 'h4', 'h5', 'h6', 'strong', 'em', 'b', 'i', 'u',
        'mark', 'small', 'del', 'ins', 'sub', 'sup', 'code', 'pre',
        'blockquote', 'q', 'cite', 'abbr', 'acronym', 'dfn', 'kbd',
        'samp', 'var', 'time', 'address', 'br', 'hr', 'wbr', 'area',
        'base', 'col', 'embed', 'link', 'meta', 'param', 'source',
        'track', 'video', 'audio', 'canvas', 'map', 'object', 'svg',
        'path', 'circle', 'rect', 'line', 'polyline', 'polygon', 'ellipse'
      ];
      
      // Process each pattern to detect icon usage
      iconPatterns.forEach(pattern => {
        let match;
        while ((match = pattern.exec(code)) !== null) {
          const componentName = match[1];
          
          // Skip excluded components
          if (excludedComponents.includes(componentName)) {
            continue;
          }
          
          // Add to imports if it looks like a Lucide icon (PascalCase, not excluded)
          if (/^[A-Z][a-zA-Z]*$/.test(componentName)) {
            imports.add(componentName);
            // Convert to kebab-case for usage tracking
            const kebabCase = componentName.replace(/([A-Z])/g, '-$1').toLowerCase().substring(1);
            iconUsage.push(kebabCase);
          }
        }
      });
      
      return {
        imports: Array.from(imports),
        iconUsage
      };
    }
    
    /**
     * Replace generic Icon usage with specific Lucide icons - DYNAMIC
     */
    function replaceIconUsage(code: string, iconUsage: string[]): string {
      let updatedCode = code;
      
      iconUsage.forEach(iconName => {
        // Convert kebab-case to PascalCase for component names
        const componentName = iconName.split('-').map(word => 
          word.charAt(0).toUpperCase() + word.slice(1)
        ).join('');
        
          // Replace <Icon name="icon-name" /> with <IconName />
          const iconPattern = new RegExp(`<Icon\\s+name\\s*=\\s*["']${iconName}["'][^>]*>`, 'g');
        updatedCode = updatedCode.replace(iconPattern, `<${componentName} />`);
        
        // DON'T replace icon: "icon-name" in object properties - keep them as strings
        // This prevents breaking socialLinks arrays and similar data structures
        // Only replace direct component usage, not string references
      });
      
      return updatedCode;
    }
    
    // Apply icon handling to the generated code
    console.log('üå∏ [GenericPipeline] Detecting and processing Lucide icons...');
    const { imports: iconImports, iconUsage } = detectAndGenerateIconImports(cleanedCode);
    
    if (iconImports.length > 0) {
      console.log('üå∏ [GenericPipeline] Found icons to import:', iconImports);
      console.log('üå∏ [GenericPipeline] Icon usage detected:', iconUsage);
      
      // Replace generic Icon usage with specific components
      cleanedCode = replaceIconUsage(cleanedCode, iconUsage);
      
      // Add proper imports INSIDE the frontmatter section
      // Deduplicate icon imports to prevent duplicates
    const uniqueIconImports = [...new Set(iconImports)];
    const importStatement = `import { ${uniqueIconImports.join(', ')} } from '@lucide/astro';`;
      
      // Find the frontmatter section and add imports INSIDE it
      const frontmatterMatch = cleanedCode.match(/^(---\s*\n)([\s\S]*?)(\n---\s*\n)/);
      if (frontmatterMatch) {
        // Check if there are already imports in the frontmatter
        const existingImports = frontmatterMatch[2];
        const hasExistingImports = existingImports.includes('import ');
        
        // Add the import statement at the beginning of the frontmatter content
        const newFrontmatterContent = hasExistingImports 
          ? `${importStatement}\n${existingImports}`
          : `${importStatement}\n\n${existingImports}`;
          
        cleanedCode = cleanedCode.replace(
          frontmatterMatch[0],
          `${frontmatterMatch[1]}${newFrontmatterContent}${frontmatterMatch[3]}`
        );
      } else {
        // Create frontmatter with imports if none exists
        cleanedCode = `---\n${importStatement}\n---\n\n${cleanedCode}`;
      }
      
      console.log('üå∏ [GenericPipeline] Icon imports and usage updated successfully');
    } else {
      console.log('üå∏ [GenericPipeline] No Lucide icons detected in generated code');
    }
    
    // COMMENTED OUT: Component validation (temporarily disabled)
    // console.log('üå∏ [GenericPipeline] Performing final validation...');
    // const validation = SmartImageExtractor.validateCode(cleanedCode, componentName);
    // if (!validation.isValid) {
    //   console.warn('üå∏ [GenericPipeline] ‚ö†Ô∏è Validation failed:', validation.errors);
    //   console.log('üå∏ [GenericPipeline] Using fallback code...');
    //   cleanedCode = generatedCode;
    //   cleanedCode = cleanedCode.replace(/{{MOCKUP_IMAGE}}/g, mockupPath);
    //   cleanedCode = cleanedCode.replace(/{{AVATAR_IMAGE}}/g, await enhancedImageService.getAvatarImage(prompt));
    // }
    
    console.log('üå∏ [GenericPipeline] Image replacement and icon handling complete, code length:', cleanedCode.length);
    
    // === FINAL SANITATION PASS ===
    // 1. COMPLETELY REMOVE duplicate Lucide imports - NO COMMENTING, JUST REMOVE
    const lucideImportPattern = /^\s*import\s+\{[^}]*\}\s+from\s+['"]@lucide\/astro['"];?\s*$/gm;
    const lucideImportsFound = cleanedCode.match(lucideImportPattern) || [];
    if (lucideImportsFound.length > 1) {
      let firstEncountered = false;
      cleanedCode = cleanedCode.replace(lucideImportPattern, (match) => {
        if (!firstEncountered) {
          firstEncountered = true;
          return match; // keep first
        }
        // COMPLETELY REMOVE duplicate - no commenting
        return '';
      });
      // Clean up any empty lines left by removed imports
      cleanedCode = cleanedCode.replace(/\n\s*\n\s*\n/g, '\n\n');
    }

    // 2. Fix malformed double-quoted URLs
    cleanedCode = cleanedCode.replace(/""https:\/\//g, '"https://');

    // 3. Ensure avatar paths always use placeholders if still hard-coded
    cleanedCode = cleanedCode.replace(/avatar\s*[:=]\s*"[A-Za-z_0-9]+\.avif"/g, `avatar: "{{AVATAR_IMAGE}}"`);

    
    // Save the component
    console.log('üå∏ [GenericPipeline] Saving component to:', filePath);
    await fs.writeFile(filePath, cleanedCode);
    console.log('üå∏ [GenericPipeline] ‚úÖ Component saved successfully');
    
    // === FEEDBACK LEARNING INTEGRATION ===
    console.log('üå∏ [GenericPipeline] Applying learning insights...');
    const learningResult = await feedbackService.applyLearningInsights(prompt, structuredIntent);
    if (learningResult.applied_insights.length > 0) {
      console.log('üå∏ [GenericPipeline] Applied learning insights:', learningResult.applied_insights);
      // Store learning insights in metadata
      irlStructure.metadata = {
        ...irlStructure.metadata,
        raw_prompt: prompt, // Store original prompt for component-specific requirements
        learning_applied: true,
        applied_insights: learningResult.applied_insights
      };
    }
    
    // === CONVERSATIONAL RECOVERY CHECK ===
    console.log('üå∏ [GenericPipeline] Checking for clarification needs...');
    const recoveryCheck = await recoveryService.analyzeForClarification(
      prompt, 
      structuredIntent, 
      structuredIntent.confidence
    );
    
    if (recoveryCheck.needs_clarification) {
      console.log('üå∏ [GenericPipeline] Clarification needed:', recoveryCheck.reasoning);
      // For now, we'll proceed but log the need for clarification
      // In a full implementation, this would trigger a user interaction
      await feedbackService.logFeedback({
        user_prompt: prompt,
        detected_intent: structuredIntent,
        success: false,
        processing_time: 0,
        retry_count: 0,
        error_message: 'Clarification needed but not implemented in current flow'
      });
    }
    
    // === ENHANCED RAG PATTERN LEARNING ===
    console.log('üå∏ [GenericPipeline] Learning from successful generation with enhanced RAG...');
    
    try {
      // Get section descriptions for comprehensive learning
      const sectionDescriptions = structuredIntent.slots?.section_descriptions || {};
      const componentDescription = sectionDescriptions[componentName] || '';
      
      // CRITICAL FIX: Check for "undefined" values before storing
      if (!cleanedCode.includes('""undefined"')) {
      await knowledgeBase.addPattern({
        id: `${componentName}-success-${Date.now()}`,
        componentName,
        userRequest: prompt,
        requirements: componentRequirements,
        generatedCode: cleanedCode,
        success: true,
        feedback: `Successfully generated with enhanced RAG. Section description: ${componentDescription}`,
        timestamp: new Date()
      });
      
      console.log('üå∏ [GenericPipeline] ‚úÖ Enhanced pattern stored in knowledge base for future RAG');
      console.log('üå∏ [GenericPipeline] Section description included in learning:', !!componentDescription);
      } else {
        console.warn('[GenericPipeline] ‚ö†Ô∏è Not storing pattern due to "undefined" values in generated code.');
      }
    } catch (learningError) {
      console.warn('üå∏ [GenericPipeline] ‚ö†Ô∏è Enhanced pattern learning failed:', learningError);
    }
    
    // Log successful generation
    await feedbackService.logFeedback({
      user_prompt: prompt,
      detected_intent: structuredIntent,
      generated_code: cleanedCode,
      validation_result: { isValid: true, errors: [], warnings: [], suggestions: [] },
      success: true,
      processing_time: Date.now(),
      retry_count: 0
    });
    
    // === LINT VALIDATION ===
    console.log('üå∏ [GenericPipeline] Validating generated code for lint errors...');
    
    // Import and use the comprehensive AstroLintValidator
    try {
      const { AstroLintValidator } = await import('../services/astro-lint-validator');
      
      // Create temporary file for validation
      const tempDir = path.join(process.cwd(), 'temp-validation');
      await fs.mkdir(tempDir, { recursive: true });
      const tempFile = path.join(tempDir, `${componentName}.astro`);
      await fs.writeFile(tempFile, cleanedCode);
      
      // Validate the component
      const validationResult = await AstroLintValidator.validateComponent(tempFile);
      
      if (!validationResult.isValid) {
        console.warn('üå∏ [GenericPipeline] Lint errors detected:', validationResult.errors);
        console.log('üå∏ [GenericPipeline] Attempting to fix lint errors...');
        
        // Fix the component
        const fixResult = await AstroLintValidator.fixComponent(tempFile);
        
        if (fixResult.isValid) {
          console.log('üå∏ [GenericPipeline] ‚úÖ Lint errors fixed successfully');
          // Read the fixed code
          cleanedCode = await fs.readFile(tempFile, 'utf-8');
        } else {
          console.warn('üå∏ [GenericPipeline] ‚ö†Ô∏è Some lint errors could not be fixed:', fixResult.errors);
        }
      } else {
        console.log('üå∏ [GenericPipeline] ‚úÖ No lint errors detected');
      }
      
      // Clean up temp directory
      await fs.rm(tempDir, { recursive: true, force: true });
      
    } catch (validationError) {
      console.warn('üå∏ [GenericPipeline] ‚ö†Ô∏è Validation service error:', validationError);
      // Fall back to basic validation
      console.log('üå∏ [GenericPipeline] Falling back to basic validation...');
      
      // Enhanced validation - check for common lint errors and issues
    const lintErrors = [];
    const codeStr = cleanedCode as string;
    
      // Check for React-style issues
    if (codeStr.includes('key={')) {
      lintErrors.push('React-style key attributes found');
    }
    if (codeStr.includes('className=')) {
      lintErrors.push('className attributes found (should be class)');
    }
    if (codeStr.includes('import') && codeStr.includes('react')) {
      lintErrors.push('React imports found');
    }
    if (codeStr.includes('useState') || codeStr.includes('useEffect')) {
      lintErrors.push('React hooks found');
    }
      
      // Check for wrong Lucide imports
      if (codeStr.includes("from 'lucide-astro'")) {
        lintErrors.push('Wrong Lucide import source: lucide-astro (should be @lucide/astro)');
      }
      if (codeStr.includes("from 'lucide-react'")) {
        lintErrors.push('Wrong Lucide import source: lucide-react (should be @lucide/astro)');
      }
      
      // Check for duplicate Lucide imports
      const lucideImportMatches = codeStr.match(/import\s+\{[^}]*\}\s+from\s+['"]@lucide\/astro['"]/g);
      if (lucideImportMatches && lucideImportMatches.length > 1) {
        lintErrors.push('Duplicate Lucide import statements found');
      }
      
      // Check for duplicate image URLs in arrays
      const imageUrlMatches = codeStr.match(/https:\/\/images\.unsplash\.com\/[^"'\s]+/g);
      if (imageUrlMatches) {
        const uniqueUrls = [...new Set(imageUrlMatches)];
        if (uniqueUrls.length < imageUrlMatches.length) {
          lintErrors.push('Duplicate Unsplash image URLs found in component');
        }
      }
      
      // Check for hardcoded image URLs instead of placeholders
      if (codeStr.includes('https://images.unsplash.com/') && !codeStr.includes('{{MOCKUP_IMAGE}}')) {
        lintErrors.push('Hardcoded Unsplash URLs found (should use {{MOCKUP_IMAGE}} placeholders)');
      }
      
      // Check for wrong video source attributes
      if (codeStr.includes('<source url=')) {
        lintErrors.push('Wrong video source attribute: url (should be src)');
      }
      
      // Check for TypeScript errors in map functions
      if (codeStr.includes('.map((') && !codeStr.includes(': ')) {
        lintErrors.push('Untyped map function parameters found');
      }
      
      // Check for non-existent Lucide icons
      const lucideIconMatches = codeStr.match(/import\s+\{[^}]*\}\s+from\s+['"]@lucide\/astro['"]/);
      if (lucideIconMatches) {
        const iconMatch = lucideIconMatches[0].match(/\{([^}]*)\}/);
        if (iconMatch) {
          const icons = iconMatch[1].split(',').map(icon => icon.trim());
          const nonExistentIcons = ['Capsule', 'Icon']; // Add more as needed
          const foundNonExistent = icons.filter(icon => nonExistentIcons.includes(icon));
          if (foundNonExistent.length > 0) {
            lintErrors.push(`Non-existent Lucide icons found: ${foundNonExistent.join(', ')}`);
          }
        }
      }
      
      // Check for malformed URLs with double quotes
      if (codeStr.includes('""https://')) {
        lintErrors.push('Malformed URLs with double quotes found');
      }
      
      // Check for missing TypeScript interfaces
      if (codeStr.includes('interface') && codeStr.includes('Astro.props') && !codeStr.includes('Partial<')) {
        lintErrors.push('Missing Partial<> wrapper for Astro.props');
      }
      
      // Check for framework-specific imports (CRITICAL ERROR)
      if (codeStr.includes("from 'solid-js'") || codeStr.includes('from "solid-js"')) {
        lintErrors.push('Framework-specific import found: solid-js (NOT compatible with Astro)');
      }
      if (codeStr.includes("from 'react'") || codeStr.includes('from "react"')) {
        lintErrors.push('Framework-specific import found: react (NOT compatible with Astro)');
      }
      if (codeStr.includes("from 'vue'") || codeStr.includes('from "vue"')) {
        lintErrors.push('Framework-specific import found: vue (NOT compatible with Astro)');
      }
      if (codeStr.includes("from 'svelte'") || codeStr.includes('from "svelte"')) {
        lintErrors.push('Framework-specific import found: svelte (NOT compatible with Astro)');
      }
      
      // Check for framework-specific hooks and functions
      if (codeStr.includes('createSignal') || codeStr.includes('createStore')) {
        lintErrors.push('Solid.js functions found (NOT compatible with Astro)');
      }
      if (codeStr.includes('useState') || codeStr.includes('useEffect')) {
        lintErrors.push('React hooks found (NOT compatible with Astro)');
      }
      if (codeStr.includes('ref(') || codeStr.includes('onMounted')) {
        lintErrors.push('Vue functions found (NOT compatible with Astro)');
      }
      if (codeStr.includes('onMount(') && codeStr.includes('svelte')) {
        lintErrors.push('Svelte functions found (NOT compatible with Astro)');
      }
      
      // Check for framework-specific event handlers
      if (codeStr.includes('onClick=') || codeStr.includes('onMouseEnter=') || codeStr.includes('onMouseLeave=')) {
        lintErrors.push('Framework-specific event handlers found (use standard HTML events)');
      }
      
      // Check for framework-specific refs
      if (codeStr.includes('ref={') || codeStr.includes('ref=')) {
        lintErrors.push('Framework-specific refs found (use standard HTML attributes)');
      }
    
    if (lintErrors.length > 0) {
      console.warn('üå∏ [GenericPipeline] Lint errors detected:', lintErrors);
      console.log('üå∏ [GenericPipeline] Attempting to fix lint errors...');
      
        // Apply comprehensive fixes
      let finalCode = cleanedCode as string;
        
        // Fix React-style issues
      finalCode = finalCode.replace(/key\s*=\s*\{[^}]+\}/g, '');
      finalCode = finalCode.replace(/className\s*=\s*["'][^"']*["']/g, (match) => match.replace('className', 'class'));
      finalCode = finalCode.replace(/import\s+.*from\s+['"]react['"];?\s*\n?/g, '');
      finalCode = finalCode.replace(/import\s+.*from\s+['"]@lucide\/react['"];?\s*\n?/g, '');
        
        // Fix wrong Lucide imports
        finalCode = finalCode.replace(/from\s+['"]lucide-astro['"]/g, "from '@lucide/astro'");
        finalCode = finalCode.replace(/from\s+['"]lucide-react['"]/g, "from '@lucide/astro'");
        
        // Fix duplicate Lucide imports by consolidating them
        const lucideImports = finalCode.match(/import\s+\{[^}]*\}\s+from\s+['"]@lucide\/astro['"]/g);
        if (lucideImports && lucideImports.length > 1) {
          const allIcons = new Set<string>();
          lucideImports.forEach(importStmt => {
            const iconMatch = importStmt.match(/\{([^}]*)\}/);
            if (iconMatch) {
              const icons = iconMatch[1].split(',').map(icon => icon.trim());
              icons.forEach(icon => allIcons.add(icon));
            }
          });
          const consolidatedImport = `import { ${Array.from(allIcons).join(', ')} } from '@lucide/astro';`;
          finalCode = finalCode.replace(/import\s+\{[^}]*\}\s+from\s+['"]@lucide\/astro['"];?\s*\n?/g, '');
          finalCode = finalCode.replace('---\n', `---\n${consolidatedImport}\n`);
        }
        
        // Fix wrong video source attributes
        finalCode = finalCode.replace(/<source\s+url\s*=\s*["']([^"']+)["']/g, '<source src="$1"');
        
        // Fix untyped map functions
        finalCode = finalCode.replace(/\.map\(\(([^)]+)\)\s*=>/g, (match, param) => {
          if (!param.includes(':')) {
            // Try to infer type from context
            if (param.includes('product')) return `.map((${param}: Product) =>`;
            if (param.includes('testimonial')) return `.map((${param}: Testimonial) =>`;
            if (param.includes('item')) return `.map((${param}: any) =>`;
            return `.map((${param}: any) =>`;
          }
          return match;
        });
        
        // Fix malformed URLs
        finalCode = finalCode.replace(/""https:\/\//g, '"https://');
        
        // Fix missing Partial<> wrapper
        finalCode = finalCode.replace(/Astro\.props;?\s*$/gm, 'Astro.props as Partial<ComponentProps>;');
        
        // Remove non-existent icons from imports
        const nonExistentIcons = ['Capsule', 'Icon'];
        nonExistentIcons.forEach(icon => {
          finalCode = finalCode.replace(new RegExp(`\\b${icon}\\b,?\\s*`, 'g'), '');
          finalCode = finalCode.replace(new RegExp(`,\\s*\\b${icon}\\b\\b`, 'g'), '');
        });
        
        // Fix framework-specific imports and convert to Astro-compatible code
        finalCode = finalCode.replace(/import\s+.*from\s+['"]solid-js['"];?\s*\n?/g, '');
        finalCode = finalCode.replace(/import\s+.*from\s+['"]solid-js\/store['"];?\s*\n?/g, '');
        finalCode = finalCode.replace(/import\s+.*from\s+['"]react['"];?\s*\n?/g, '');
        finalCode = finalCode.replace(/import\s+.*from\s+['"]vue['"];?\s*\n?/g, '');
        finalCode = finalCode.replace(/import\s+.*from\s+['"]svelte['"];?\s*\n?/g, '');
        
        // Remove framework-specific function calls
        finalCode = finalCode.replace(/const\s+\[[^\]]+\]\s*=\s*createSignal\([^)]+\)/g, 'let currentIndex = 0');
        finalCode = finalCode.replace(/const\s+\[[^\]]+\]\s*=\s*createStore\([^)]+\)/g, '');
        finalCode = finalCode.replace(/setCurrentIndex\(/g, 'currentIndex = ');
        finalCode = finalCode.replace(/setIsPlaying\(/g, 'isPlaying = ');
        
        // Convert framework-specific event handlers to standard HTML
        finalCode = finalCode.replace(/onClick=\{([^}]+)\}/g, 'onclick="$1"');
        finalCode = finalCode.replace(/onMouseEnter=\{([^}]+)\}/g, 'onmouseenter="$1"');
        finalCode = finalCode.replace(/onMouseLeave=\{([^}]+)\}/g, 'onmouseleave="$1"');
        
        // Convert framework-specific refs to standard HTML
        finalCode = finalCode.replace(/ref=\{([^}]+)\}/g, 'id="$1"');
        
        // Replace hardcoded Unsplash URLs with placeholders
        finalCode = finalCode.replace(/https:\/\/images\.unsplash\.com\/[^"'\s]+/g, '{{MOCKUP_IMAGE}}');
      
      cleanedCode = finalCode;
      console.log('üå∏ [GenericPipeline] Lint errors fixed, final code length:', cleanedCode.length);
    } else {
        console.log('ÔøΩÔøΩ [GenericPipeline] ‚úÖ No lint errors detected');
    }
    
    console.log('üå∏ [GenericPipeline] === COMPONENT GENERATION COMPLETE ===');
    generatedComponents.push(filePath);
  }
  
  // Update index.astro with all generated components
  console.log('üå∏ [GenericPipeline] Updating index.astro with all components...');
  await updateGenericIndexAstroWithSections(componentNames);
  console.log('üå∏ [GenericPipeline] ‚úÖ Index.astro updated');
  
  // === FINAL METRICS AND LEARNING ===
  console.log('üå∏ [GenericPipeline] Generating learning metrics...');
  try {
    const metrics = await feedbackService.generateMetrics();
    console.log('üå∏ [GenericPipeline] Learning metrics:', {
      total_requests: metrics.total_requests,
      success_rate: `${Math.round((metrics.successful_requests / metrics.total_requests) * 100)}%`,
      average_processing_time: `${Math.round(metrics.average_processing_time)}ms`
    });
  } catch (error) {
    console.warn('üå∏ [GenericPipeline] Error generating metrics:', error);
  }
  
  console.log('üå∏ [GenericPipeline] === ENHANCED GENERIC CREATE PIPELINE COMPLETE ===');
  console.log('üå∏ [GenericPipeline] Generated components:', generatedComponents);
  
  return { success: true, componentPaths: generatedComponents };
}

    // Simple validation - check for external domains and non-atomic components

// === MISSING FUNCTION DEFINITIONS ===

// Single pipeline functions
function getSingleComponentsDir(): string {
  return path.join(process.cwd(), '..', 'rendering', 'src', 'components', 'single');
}

function sanitizeSingleComponentName(name: string): string {
  return name.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
}

async function getSingleMockupImagePath(): Promise<string> {
    const { enhancedImageService } = await import('../services/image-service');
  return await enhancedImageService.getMockupImage();
}

async function updateSingleIndexAstroComponent(componentName: string, prompt: string): Promise<void> {
  // Implementation for single component index update
  console.log('[SinglePipeline] Updating index with component:', componentName);
}

// Abstract pipeline functions
function getAbstractComponentsDir(): string {
  return path.join(process.cwd(), '..', 'rendering', 'src', 'components', 'abstract');
}

function sanitizeAbstractComponentName(name: string): string {
  return name.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
}

async function getAbstractMockupImagePath(): Promise<string> {
    const { enhancedImageService } = await import('../services/image-service');
  return await enhancedImageService.getMockupImage();
}

async function updateAbstractIndexAstroWithSections(componentNames: string[]): Promise<void> {
  // Implementation for abstract components index update
  console.log('[AbstractPipeline] Updating index with components:', componentNames);
}

  // NEW: Placeholder replacement function to handle the new placeholder system
  async function replaceImagePlaceholders(code: string, componentName: string, prompt?: string): Promise<string> {
    console.log('üå∏ [GenericPipeline] Replacing image placeholders...');
    
    const { enhancedImageService } = await import('../services/image-service');
    
    // Replace different types of placeholders with appropriate images
    const replacements = [
      {
        placeholder: '{{PRODUCT_IMAGE}}',
        searchTerm: 'product',
        fallback: '/images/mockups/product.jpg'
      },
      {
        placeholder: '{{AVATAR_IMAGE}}',
        searchTerm: 'portrait',
        fallback: '/images/avatars/Avatar_man.avif'
      },
      {
        placeholder: '{{HERO_IMAGE}}',
        searchTerm: 'hero background',
        fallback: '/images/mockups/mackbook.jpg'
      },
      {
        placeholder: '{{GALLERY_IMAGE}}',
        searchTerm: 'gallery',
        fallback: '/images/mockups/shoes.jpg'
      },
      {
        placeholder: '{{TESTIMONIAL_IMAGE}}',
        searchTerm: 'portrait',
        fallback: '/images/avatars/Avatar_woman2.avif'
      }
    ];
    
    let processedCode = code;
    
    for (const replacement of replacements) {
      if (processedCode.includes(replacement.placeholder)) {
        console.log(`üå∏ [GenericPipeline] Fetching image for: ${replacement.searchTerm}`);
        const imageUrl = await enhancedImageService.getMockupImage(
          replacement.searchTerm,
          prompt,
          componentName,
          {}
        );
        
        const finalImage = imageUrl || replacement.fallback;
        processedCode = processedCode.replace(new RegExp(replacement.placeholder, 'g'), finalImage);
        console.log(`üå∏ [GenericPipeline] Replaced ${replacement.placeholder} with: ${finalImage}`);
      }
    }
    
    return processedCode;
  }
}
  